<!DOCTYPE html>
<html>
<head>
    <title>Cryptomatic</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #1e1e1e;
            color: white;
            margin: 0;
            padding: 0;
        }

        h1 {
            text-align: center;
            margin-top: 20px;
            color: white;
        }

        p {
            text-align: center;
            margin-top: 5px;
            font-size: 1.2em;
        }

        .trading-button {
            display: inline-block;
            margin: 10px auto;
            padding: 10px 20px;
            background-color: rgb(7, 131, 184);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .trading-button:hover {
            background-color: rgb(15, 88, 134);
        }

        /* Timer text */
        #timer {
            text-align: center;
            font-size: 1em;
            margin-top: 10px;
            color: white;
        }

        /* Container for top picks cryptos */
        .crypto-container {
            margin: 20px auto;
            max-width: 650px;
            padding: 15px;
            background-color: #2c2c2c;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        .crypto-item {
            margin-bottom: 20px;
            padding: 10px;
            border-bottom: 1px solid #444;
            display: flex; 
            justify-content: space-between; 
            align-items: center;
        }
        .crypto-item:last-child {
            border-bottom: none;
        }

        a {
            color: white;
            text-decoration: none;
            font-weight: bold;
        }
        a:hover {
            text-decoration: underline;
        }

        .crypto-title_style {
            font-size: 1.5em;
            margin-bottom: 10px;
        }

        /* Main table */
        table {
            border-collapse: collapse;
            margin: 10px auto;
            width: 95%;
            text-align: left;
        }
        th, td {
            border: 1px solid #444;
            padding: 8px 12px;
            text-align: center;
        }
        th {
            background-color: #333;
            cursor: pointer;
            color: white;
        }
        td {
            background-color: inherit;
        }

        /* Refresh Button */
        #refreshButton {
            display: inline-block;
            margin: 10px 5px;
            padding: 10px 20px;
            background-color: green;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #refreshButton:hover {
            background-color: darkgreen;
        }

        .arrow-up {
            display: none;
        }
        .arrow-down {
            display: none;
        }

        .trend-up {
            color: green;
        }
        .trend-down {
            color: red;
        }
        .neutral {
            color: grey;
        }
        .buyOrderStatus {
            margin-left: 10px;
            display: none;
            transition: color 0.3s ease;
        }

        .error-message {
            color: red;
            font-size: 0.9em;
            margin-top: 5px;
            display: none;
        }
        
        button {
            align-self: flex-end !important; 
        }

        .status-text {
            color: #666;
        }
        .status-text, .buyOrderStatus {
            text-align: left;
        }
        td[style*="display: flex"] {
            justify-content: flex-start !important;
        }

        .trade-cell {
            display: flex;
            align-items: flex-end;  
            align-items: center;
            gap: 10px;
            padding-left: 20px !important;
            padding-right: 0 !important;
        }

        .status-container {
            text-align: left;
            justify-content: flex-start;
            display: inline-flex;
            align-items: center;
            height: 29px;
            background: black;
            padding: 0 10px;
            font-size: 0.9em;
            align-self: flex-end !important;
            position: relative;
        }

        .polling-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: none;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.2; }
            100% { opacity: 1; }
        }

        .cancel-button {
            background-color: #cd3331 !important;
        }
        .cancel-button:hover {
            background-color: #a62a28 !important;
        }
        button.cancel-button {
            background-color: #cd3331 !important;
        }
        button.cancel-button:hover {
            background-color: #a62a28 !important;
        }
        .trade-cell, tr[style*="background-color: #2a4843"] td {
            background-color: inherit;
        }
        .sell-btn {
            background-color: #be5635; /* Orange-500 */
            display: inline-block;
            color: white;
            border: none;
            border-radius: 0;
            height: 30px;
            padding: 5px 15px;
            cursor: pointer;
            text-transform: uppercase;
        }

        .sell-btn:hover:not(:disabled) {
            background-color: #91422a; /* Orange-600 */
        }

        .sell-btn:disabled {
            background-color: #bebebe !important; /* Gray */
            cursor: not-allowed;
        }

        /* Ensure hover doesn't change the background of disabled buttons */
        .sell-btn:disabled:hover {
            background-color: #bebebe !important;
        }

        /* Results bar and transaction history styles */
        .results-bar {
            width: 95%;
            margin: 20px auto 0;
            background-color: #000;
            padding: 5px 0;
            color: white;
            text-align: center;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
            font-size: 0.9em;
            font-weight: normal;
        }

        .results-content {
            width: 95%;
            margin: 0 auto;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            background-color: #000;
            border-bottom-left-radius: 4px;
            border-bottom-right-radius: 4px;
        }

        .results-content.open {
            max-height: 800px; /* Increased from 500px to allow more vertical space */
        }

        .transaction-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85em;
            font-weight: normal;
        }

        .transaction-table th,
        .transaction-table td {
            padding: 6px 8px;
            text-align: left;
            border-bottom: 1px solid #333;
        }

        .transaction-table th {
            font-weight: normal;
            color: #888;
            background-color: #000;  /* Match the black background */
        }

        .positive-gain {
            color: #00ff00;
        }

        .negative-gain {
            color: #ff0000;
        }

        .down-arrow {
            display: inline-block;
            transition: transform 0.3s ease;
        }

        .down-arrow.open {
            transform: rotate(180deg);
        }
        .auto-trade-button {
            background-color: #ff8c00;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 20px;
            cursor: pointer;
            margin-left: 10px;
        }

        .auto-trade-button.active {
            background-color: #dc3545;
        }

        .auto-trade-button:hover {
            background-color: #e67e00;
        }

        .auto-trade-button.active:hover {
            background-color: #c82333;
        }
        #orderMonitorRoot {
            width: 95%;
            height: 0;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        .daily-row {
            cursor: pointer;
            background-color: #1a1a1a;
        }

        .daily-row:hover {
            background-color: #2a2a2a;
        }

        .transaction-details {
            max-height: 0;
            display: none;
            opacity: 0;
            overflow: hidden;
            transform: translateY(-20px);
            background-color: #000;
            transition: opacity 0.2s ease, transform 0.2s ease;
        }

        .transaction-details.open {
            display: table-row;
            opacity: 1;
            transform: translateY(0);
        }

        .detail-row td {
            padding: 6px 15px;
            border-bottom: 1px solid #333;
        }

        .transaction-details table {
            width: 100%;
            border-collapse: collapse;
        }

        .detail-row {
            font-size: 0.9em;
            color: #888;
        }

        .detail-row td {
            padding: 6px 15px;
        }

        .detail-row td:first-child {
            padding-left: 30px;
        }

        .day-arrow {
            display: inline-block;
            transition: transform 0.3s ease;
            margin-right: 8px;
            transform: rotate(0deg);
        }

        .day-arrow.open {
            transform: rotate(90deg);
        }

        .daily-row {
            cursor: pointer;
            background-color: #1a1a1a;
        }

        .daily-row:hover {
            background-color: #2a2a2a;
        }

        .trades-count {
            color: #666;
        }
        .daily-row {
            cursor: pointer;
            background-color: #000000;  /* Changed from #1a1a1a to black */
        }

        .daily-row:hover {
            background-color: #1a1a1a;  /* Keep hover a bit lighter for feedback */
        }

        .transaction-details {
            max-height: 0;
            opacity: 0;
            transform: translateY(-20px);
            background-color: #000;
            transition: max-height 0.3s ease-out,
                        opacity 0.2s ease-out,
                        transform 0.2s ease-out;
        }

        .detail-row {
            background-color: #000000;  /* Add explicit black background */
        }

        .transaction-table th,
        .transaction-table td {
            padding: 6px 8px;
            text-align: left;
            border-bottom: 1px solid #333;
            background-color: #000000;  /* Add black background to all cells */
        }

        .transaction-table th {
            font-weight: normal;
            color: #888;
        }

        /* If you need stronger borders between rows */
        .transaction-table tr {
            border-bottom: 1px solid #333;
        }

        .chart-row {
            display: none;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
            max-height: 0;
            opacity: 0;
            overflow: hidden;
        }
        .chart-row-visible {
            display: table-row;
            max-height: 600px;
            opacity: 1;
        }
        .chart-row td {
            padding: 0;
        }
        .buy-btn {
            background-color: #0077cc;
            display: inline-block;
            color: white;
            border: none;
            border-radius: 0;
            height: 30px;
            padding: 5px 15px;
            cursor: pointer;
            text-transform: uppercase;
        }

        .buy-btn:hover {
            background-color: #005599;
        }
        /* Account popup styles */
        .account-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #1e1e1e;
            border: 1px solid #444;
            border-radius: 5px;
            padding: 20px;
            z-index: 1000;
            max-width: 800px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .account-popup h3 {
            margin-top: 0;
            color: white;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }

        .account-popup table {
            width: 100%;
            margin: 10px 0;
            border-collapse: collapse;
        }

        .account-popup th {
            background-color: #2c2c2c;
            padding: 8px;
            text-align: left;
        }

        .account-popup td {
            padding: 8px;
            border-bottom: 1px solid #333;
        }

        .account-popup .cancel-order-btn {
            background-color: #cd3331;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        }

        .account-popup .cancel-order-btn:hover {
            background-color: #a62a28;
        }

        .account-popup .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: #666;
            font-size: 20px;
            cursor: pointer;
        }

        .account-popup .close-btn:hover {
            color: #999;
        }

        .popup-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }
        .account-info-title {
            text-align: center;
            margin-top: 20px;
            color: rgb(255, 175, 83);
            font-weight: normal;
            text-transform: uppercase;
            font-size: 1.4em;
        }

        .account-section-title {
            text-align: left;
            font-weight: normal;
            text-transform: uppercase;
            font-size: 0.9em;
        }

        .account-table {
            border-collapse: collapse;
            margin: 10px auto;
            width: 95%;
            text-align: left;
        }

        .account-table th, .account-table td {
            border: 1px solid #444;
            padding: 8px 12px;
            text-align: center;
            font-weight: normal;
        }

        .account-table th {
            background-color: #333;
            color: white;
        }

        .account-table td {
            background-color: inherit;
        }

        .cancel-button.reset-button {
            background-color: #ff8c00 !important;  /* Orange/yellow color */
            border-color: #ff8c00 !important;
        }

        .cancel-button.reset-button:hover {
            background-color: #e67e00 !important;  /* Darker orange on hover */
            border-color: #e67e00 !important;
        }
        #crypto-news-bar {
            width: 95%;
            margin: 20px auto 10px;
            background-color: black;
            padding: 8px 15px;
            color: white;
            text-align: center;
            font-size: 0.9em;
            font-weight: normal;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }

        #crypto-news-content {
            position: absolute;
            width: 100%;
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: #d8a239;
        }

        .fade-out {
            opacity: 0;
            transform: translateY(-20px);
        }

        .fade-in {
            opacity: 1;
            transform: translateY(0);
        }
        @media screen and (max-width: 1920px) {
            #cryptoTable th:nth-child(4), /* Spread column header */
            #cryptoTable td:nth-child(4), /* Spread column data */
            #cryptoTable th:nth-child(5), /* Volume column header */
            #cryptoTable td:nth-child(5)  /* Volume column data */
            {
                display: none;
            }
        }
        @media screen and (max-width: 1200px) {
            #cryptoTable th:nth-child(3), /* RoC column header */
            #cryptoTable td:nth-child(3), /* RoC column data */
            #cryptoTable th:nth-child(7), /* High | Low column header */
            #cryptoTable td:nth-child(7) /* High | Low column data */
            {
                display: none;
            }
        }
        @media screen and (max-width: 900px) {
            #cryptoTable th:nth-child(2), /* Price column header */
            #cryptoTable td:nth-child(2), /* Price column data */
            #cryptoTable th:nth-child(8), /* Time column header */
            #cryptoTable td:nth-child(8) /* Time column data */
            {
                display: none;
            }
        }
        .sell-type-select {
            background-color: #1e1e1e;
            color: white;
            border: 1px solid #444;
            border-radius: 5px;
            padding: 8px 12px;
            cursor: pointer;
        }
        /* Updated styles for the transaction history with fee information */

        /* Time zone indicator for column header */
        .transaction-table th:first-child::after {
            content: "";
            font-size: 0.8em;
            color: #aaa;
            font-weight: normal;
        }

        /* Styling for fees column */
        .transaction-table td:nth-child(6) {
            color: #ff9900;  /* Orange color for fees */
        }

        /* Hover effect for transaction details */
        .detail-row:hover {
            background-color: #2a2a2a;
        }

        /* Style for fee info tooltip */
        .fee-info {
            position: relative;
            display: inline-block;
            cursor: help;
        }

        .fee-info .tooltip {
            visibility: hidden;
            width: 200px;
            background-color: #333;
            color: #fff;
            text-align: left;
            border-radius: 4px;
            padding: 8px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.9em;
            pointer-events: none;
        }

        .fee-info:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }

        /* Add a small indicator to show it's hoverable */
        .fee-info::after {
            content: "â“˜";
            font-size: 0.7em;
            vertical-align: super;
            margin-left: 2px;
            color: #888;
        }

        /* Time formatting in Pacific Time */
        .pacific-time {
            color: #aaa;
            font-family: monospace;
        }
        /* Fee indicator styles */
        #fee-indicator-container {
            margin-left: 10px;
            padding: 5px 10px;
            background-color: #2c2c2c;
            border-radius: 4px;
            font-size: 0.8em;
            transition: background-color 0.3s ease;
        }

        #fee-indicator-container.fee-highlight {
            background-color: #3a3a3a;
        }

        .adjusted-indicator {
            display: block;
            font-size: 0.7em;
            color: #ffaa44;
            margin-top: 2px;
        }
        .trade-cell label {
            text-align: left;
            display: block;
            margin-left: 4px; /* Optional: adds a small left margin for better visual alignment */
        }
        </style>
    <link rel="icon" href="https://displaying.xyz/favicon.ico" type="image/x-icon"/>

    <script>
        let autoRefreshInterval;
        window.feeAdjustmentsApplied = false;

        /**
         * Unified function to calculate fee-adjusted stop-loss and take-profit values
         * while maintaining the correct risk-reward ratio
         * 
         * @param {number} stopLossPercent - Original stop-loss percentage (display value)
         * @param {Object} feeRates - Object containing maker and taker fee rates
         * @returns {Object} Object with actualStopLoss, displayStopLoss, actualTakeProfit, displayTakeProfit
         */
        async function calculateFeeAdjustedStopLossAndTakeProfit(stopLossPercent) {
            // Get current fee rates
            const feeRates = await getCurrentFeeRates();
            
            // The ratio we want to maintain (5.8:1)
            const riskRewardRatio = 5.8;
            
            // Calculate the actual stop-loss (what's sent to API) by subtracting the fee
            const actualStopLoss = Math.max(0.1, stopLossPercent - feeRates.taker);
            
            // Calculate the actual take-profit based on the risk-reward ratio
            const actualTakeProfit = actualStopLoss * riskRewardRatio;
            
            // Calculate display values (what user sees)
            const displayStopLoss = stopLossPercent; // Already includes fee
            const displayTakeProfit = Math.max(0.1, actualTakeProfit - feeRates.taker);
            
            console.log(`Fee-adjusted values calculated with ratio ${riskRewardRatio}:1`);
            console.log(`Stop Loss: Display ${displayStopLoss.toFixed(2)}%, Actual ${actualStopLoss.toFixed(2)}%`);
            console.log(`Take Profit: Display ${displayTakeProfit.toFixed(2)}%, Actual ${actualTakeProfit.toFixed(2)}%`);
            
            return {
                actualStopLoss,
                displayStopLoss,
                actualTakeProfit,
                displayTakeProfit
            };
        }

        async function getUserFeeTier() {
            try {
                const response = await fetch('/api/user_fee_tier');
                if (!response.ok) {
                    console.warn("Couldn't get user fee tier, using default");
                    return 'default';
                }
                const text = await response.text();
                
                try {
                    // Wrap 'default' in quotes to make it a valid JSON string
                    const data = JSON.parse(`"${text.trim()}"`);
                    return data;
                } catch (jsonError) {
                    console.error('JSON parsing error:', jsonError);
                    console.log('Raw response text:', text);
                    return 'default';
                }
            } catch (error) {
                console.warn("Error getting fee tier:", error);
                return 'default';
            }
        }

        // Cache the fee rates to avoid repeated calculations
        let cachedFeeRates = null;
        let lastFeeTierCheck = 0;
        const FEE_TIER_CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

        // Get the current fee rates (with caching)
        async function getCurrentFeeRates() {
    const now = Date.now();
    
    // Use cached values if available and recent
    if (cachedFeeRates && (now - lastFeeTierCheck) < FEE_TIER_CACHE_DURATION) {
        return cachedFeeRates;
    }
    
    try {
        // Fetch current trading tier
        let tier;
        try {
            const response = await fetch('/api/user_fee_tier');
            if (!response.ok) {
                console.warn("Couldn't get user fee tier, using default");
                tier = 'default';
            } else {
                const text = await response.text();
                const cleanText = text.trim();
                
                try {
                    // First try to parse as JSON if it's wrapped in quotes
                    tier = JSON.parse(cleanText);
                } catch (jsonError) {
                    // If not valid JSON, use as-is (likely 'default')
                    tier = cleanText;
                    console.log('Using tier string directly:', tier);
                }
            }
        } catch (error) {
            console.warn("Error getting fee tier:", error);
            tier = 'default';
        }
        
        // Define all fee tiers (same as your backend)
        const KRAKEN_FEES = {
            'default': {
                'maker': 0.16,
                'taker': 0.26
            },
            '50k+': {
                'maker': 0.14,
                'taker': 0.24
            },
            '100k+': {
                'maker': 0.12,
                'taker': 0.22
            },
            '250k+': {
                'maker': 0.10,
                'taker': 0.20
            },
            '500k+': {
                'maker': 0.08,
                'taker': 0.18
            },
            '1m+': {
                'maker': 0.06,
                'taker': 0.16
            },
            '2.5m+': {
                'maker': 0.04,
                'taker': 0.14
            },
            '5m+': {
                'maker': 0.02,
                'taker': 0.12
            },
            '10m+': {
                'maker': 0.00,
                'taker': 0.10
            }
        };
        
        // Get the fee rates for the current tier (or default)
        cachedFeeRates = KRAKEN_FEES[tier] || KRAKEN_FEES['default'];
        lastFeeTierCheck = now;
        
        return cachedFeeRates;
    } catch (error) {
        console.error("Error calculating fee rates:", error);
        // Fallback to default fees
        return { maker: 0.16, taker: 0.26 };
    }
}

async function checkCryptoBalance(cryptoName) {
    try {
        // Fetch account data
        const response = await fetch('/api/check_account');
        if (!response.ok) {
            console.warn('Failed to fetch account data, assuming no balance');
            return 0;
        }
        
        const data = await response.json();
        if (data.error) {
            console.warn('Error in account data, assuming no balance');
            return 0;
        }
        
        // Find balance for this crypto
        const balance = data.balances.find(b => b.name === cryptoName);
        return balance ? balance.quantity : 0;
    } catch (error) {
        console.error('Error checking balance:', error);
        return 0; // Default to 0 if there's an error
    }
}

async function initializeButtonStates() {
    try {
        console.log('Starting button state initialization...');
        // Get account info
        const response = await fetch('/api/check_account');
        const data = await response.json();
        
        if (data.error) {
            console.error('Error checking account:', data.error);
            return;
        }

        // Get all rows
        const rows = document.querySelectorAll('#cryptoTableBody tr');
        console.log(`Found ${rows.length} rows to process`);
        
        // Get saved amount selection
        const savedAmount = localStorage.getItem("amountSelection") || "20";
        
        // Process each row
        for (const row of rows) {
            const titleEl = row.querySelector('.crypto-title');
            if (!titleEl) continue;  // Skip row if no title element found

            const cryptoName = titleEl.textContent.trim();
            const sellBtn = row.querySelector('.sell-btn');
            const buyBtn = row.querySelector('.buy-btn');
            
            if (!sellBtn || !buyBtn) {
                console.log(`Missing buttons for ${cryptoName}`);
                continue;
            }

            // Check if there's any balance for this crypto
            const cryptoBalance = data.balances.find(b => b.name === cryptoName);
            const hasBalance = cryptoBalance && cryptoBalance.quantity > 0;

            // Check if there's an open sell order of any type
            const openSellOrder = data.orders.find(o => 
                o.name === cryptoName && 
                o.order.toLowerCase().includes('sell') &&
                !o.status.toLowerCase().includes('canceled')
            );

            console.log(`${cryptoName}: hasBalance=${!!hasBalance}, openSellOrder=${!!openSellOrder}`);
            
            // Set the appropriate button states
            if (hasBalance) {
                // Enable sell button if there's balance and no open sell order
                if (!openSellOrder) {
                    sellBtn.disabled = false;
                    sellBtn.style.backgroundColor = '#f97316';
                    sellBtn.style.cursor = 'pointer';
                } else {
                    sellBtn.disabled = true;
                    sellBtn.style.backgroundColor = '#bebebe';
                    sellBtn.style.cursor = 'not-allowed';
                }
            } else {
                // Disable sell button if no balance
                sellBtn.disabled = true;
                sellBtn.style.backgroundColor = '#bebebe';
                sellBtn.style.cursor = 'not-allowed';
            }
            
            // Buy button is always enabled
            buyBtn.disabled = false;
            buyBtn.style.backgroundColor = '#0077cc';
            buyBtn.style.cursor = 'pointer';
        }
        
        console.log('Button state initialization complete');
    } catch (error) {
        console.error('Error initializing button states:', error);
    }
}

async function testConnection() {
    const response = await fetch('/api/test_connection');
    const data = await response.json();
    alert(JSON.stringify(data, null, 2));
}

async function checkForUpdates() {
    try {
        // Safely get the button from the event
        const button = event?.target;
        if (!button) {
            console.error('No button found for update check');
            return;
        }

        const originalText = button.textContent;
        button.textContent = "Checking...";
        button.disabled = true;

        // Make a request to the backend to check for updates
        const response = await fetch('/api/check_updates');
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error('Update check failed:', response.status, errorText);
            throw new Error(`Update check failed: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.updateAvailable) {
            // If updates are available, confirm with the user
            if (confirm(`Updates available (v${data.newVersion})! Do you want to update now?`)) {
                // Show download progress
                button.textContent = "Downloading...";
                
                // Request to download and install updates
                const updateResponse = await fetch('/api/install_updates', {
                    method: 'POST'
                });
                
                if (!updateResponse.ok) {
                    throw new Error('Failed to install updates');
                }
                
                const updateResult = await updateResponse.json();
                
                if (updateResult.success) {
                    alert("Update successful! The application will now restart.");
                    
                    // Reload the page to apply updates
                    window.location.reload(true);
                } else {
                    throw new Error(updateResult.error || 'Update failed');
                }
            } else {
                // User declined update
                button.textContent = originalText;
                button.disabled = false;
            }
        } else {
            // No updates available
            alert("You're already running the latest version!");
            button.textContent = originalText;
            button.disabled = false;
        }
    } catch (error) {
        console.error('Update check failed:', error);
        alert(`Error checking for updates: ${error.message}`);
        
        // Reset button state
        const button = event.target;

        if (button) {
            button.textContent = "Update";
            button.disabled = false;
        }
    } finally {
        button.textContent = originalText;
        button.disabled = false;
    }
}

/**
 * Calculates the stop-loss value based on a given take-profit value
 * Maintains a 1:5.8 risk-reward ratio with minimum stop-loss of 0.2
 * 
 * @param {number} takeProfit - The take-profit value
 * @returns {Object} - An object containing both stop-loss and take-profit values
 */
 function calculateStopLossFromTakeProfit(takeProfit) {
  // Calculate stop-loss based on the 5.8:1 ratio
  const riskRewardRatio = 5.8;
  let stopLoss = takeProfit / riskRewardRatio;
  
  // Apply minimum stop-loss rule
  if (stopLoss < 0.2) {
    stopLoss = 0.2;
    // Recalculate take-profit to maintain the ratio
    takeProfit = stopLoss * riskRewardRatio;
  }
  
  return {
    stopLoss: stopLoss,
    takeProfit: takeProfit
  };
}

/**
 * Calculates the adjusted stop-loss and take-profit values maintaining a 1:5.8 risk-reward ratio
 * @param {number} calculatedStopLoss - The initially calculated stop-loss value
 * @returns {Object} - An object containing the adjusted stop-loss and take-profit values
 */
function calculateRiskRewardValues(calculatedStopLoss) {
  // Enforce minimum stop-loss of 0.2
  const adjustedStopLoss = Math.max(0.2, calculatedStopLoss);
  
  // Calculate take-profit maintaining the 5.8:1 ratio (1.16:0.2)
  const riskRewardRatio = 5.8;
  const takeProfit = adjustedStopLoss * riskRewardRatio;
  
  return {
    stopLoss: adjustedStopLoss,
    takeProfit: takeProfit
  };
}

        function updateAutoRefresh(minutes) {
            localStorage.setItem('autoRefreshInterval', minutes);
            
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
            }
            
            if (minutes > 0) {
                autoRefreshInterval = setInterval(() => {
                    window.location.reload();
                }, minutes * 60 * 1000);
            }
        }

        // Initialize pctTrackers
        window.pctTrackers = {};

        function generateRequestId() {
            const timestamp = Date.now();
            const random = Math.random().toString(36).substring(7);
            return `req-${timestamp}-${random}`;
        }

        const MIN_REFRESH_INTERVAL = 2 * 60 * 1000; // 2 minutes in milliseconds
        let isRefreshingData = false;
        let lastRefreshTimestamp = Date.now();
        let currentSortColumn = -1; 
        let currentSortOrder = "asc";
        let autoTradeActive = false;
        let currentAutoTradeId = null;

        // Add the global state initializations here
        window.order_states = {};
        window.orderPollingIntervals = {};

        // Store open orders for both top picks and table rows:
        // rowId -> { order_id, pair }
        const openOrders = {};

        function updateAutoRefreshVisibility(isTrading) {
            const autoRefreshSelect = document.getElementById('autoRefreshSelect');
            const autoRefreshContainer = autoRefreshSelect.parentElement;
            
            if (isTrading) {
                const savedInterval = autoRefreshSelect.value;
                if (savedInterval !== "0") {
                    // Store current selection and pause refresh
                    localStorage.setItem('pausedRefreshInterval', savedInterval);
                    clearInterval(autoRefreshInterval);
                    
                    // Hide dropdown, show paused text
                    autoRefreshSelect.style.display = 'none';
                    const pausedText = document.createElement('span');
                    pausedText.id = 'refreshPausedText';
                    pausedText.style.color = '#ff8c00';
                    pausedText.textContent = '[ Refresh Paused ]';
                    autoRefreshContainer.insertBefore(pausedText, autoRefreshSelect);
                }
            } else {
                // Check if we had a saved interval
                const pausedInterval = localStorage.getItem('pausedRefreshInterval');
                if (pausedInterval) {
                    // Remove paused text, show dropdown
                    const pausedText = document.getElementById('refreshPausedText');
                    if (pausedText) pausedText.remove();
                    autoRefreshSelect.style.display = '';
                    
                    // Restore interval
                    autoRefreshSelect.value = pausedInterval;
                    updateAutoRefresh(parseInt(pausedInterval));
                    localStorage.removeItem('pausedRefreshInterval');
                }
            }
        }
        
        function toggleCryptoChart(expander) {
    const row = expander.closest('tr');
    const existingChartRow = row.nextElementSibling;
    
    // Toggle rotation of arrow
    expander.style.transform = expander.style.transform === 'rotate(90deg)' ? 'rotate(0deg)' : 'rotate(90deg)';
    
    // If chart row already exists, just toggle its visibility
    if (existingChartRow && existingChartRow.classList.contains('chart-row')) {
        existingChartRow.classList.toggle('chart-row-visible');
        return;
    }
    
    // Create new chart row
    const cryptoName = row.querySelector('.crypto-title').textContent.trim().toUpperCase();
    const fullSymbol = `${cryptoName}USD`;
    const chartRow = document.createElement('tr');
    chartRow.classList.add('chart-row', 'chart-row-visible');
    
    const chartCell = document.createElement('td');
    chartCell.colSpan = 9;
    chartCell.style.backgroundColor = 'black';
    chartCell.style.padding = '10px';
    chartCell.style.width = '100%';
    
    const chartContainer = document.createElement('div');
    chartContainer.id = `tradingview_chart_container_${fullSymbol}`;
    chartContainer.style.width = '100%';
    chartContainer.style.height = '600px';
    
    chartCell.appendChild(chartContainer);
    chartRow.appendChild(chartCell);
    
    // Insert the new row after the current row
    row.parentNode.insertBefore(chartRow, row.nextSibling);
    
    // Define default chart configuration
    const defaultConfig = {
        charts: [{
            paneProperties: {
                background: "#110f14",
                vertGridProperties: { color: "#2b2f36" },
                horzGridProperties: { color: "#2b2f36" },
                crossHairProperties: { color: "#4d5057" },
                legendProperties: {
                    showStudyArguments: true,
                    showStudyTitles: false,
                    showStudyValues: false,
                    showSeriesTitle: true,
                    showSeriesOHLC: true
                }
            },
            scalesProperties: {
                textColor: "#a5a8ad"
            },
            mainSeriesProperties: {
                candleStyle: {
                    upColor: "#23ba75",
                    downColor: "#f5395e",
                    borderUpColor: "#27b065",
                    borderDownColor: "#e65a5a",
                    wickUpColor: "#27b065",
                    wickDownColor: "#e65a5a",
                    barColorsOnPrevClose: false
                },
                showPriceLine: true,
                volumeStyle: {
                    volumeColor0: "#e65a5a",
                    volumeColor1: "#27b065"
                }
            }
        }],
        volumePaneSize: "medium",
        toolTip: {
            borderColor: "#4d5057",
            backgroundColor: "#1e2026",
            textColor: "#a5a8ad"
        }
    };
    
    // Load TradingView script and initialize chart
    const script = document.createElement('script');
    script.src = 'https://s3.tradingview.com/tv.js';
    script.onload = () => {
    const widget = new TradingView.widget({
        container_id: `tradingview_chart_container_${fullSymbol}`,
        symbol: `${fullSymbol}`,
        interval: '5',
        timezone: 'America/Los_Angeles',
        theme: 'dark',
        style: '1',
        locale: 'en',
        width: '100%',
        height: '600',
        toolbar_bg: '#000000',
        enable_publishing: false,
        hide_side_toolbar: true,
        allow_symbol_change: false,
        save_image: false,
        time: '6h',
        overrides: {
            "paneProperties.background": "#110f14", // Main chart background
            "paneProperties.vertGridProperties.color": "#2b2f36", // Vertical grid lines
            "paneProperties.horzGridProperties.color": "#2b2f36", // Horizontal grid lines
            "paneProperties.crossHairProperties.color": "#4d5057", // Crosshair
            "scalesProperties.textColor": "#a5a8ad", // Price and time labels

            // Candle colors
            "mainSeriesProperties.candleStyle.upColor": "#23ba75", // Bullish candles (green)
            "mainSeriesProperties.candleStyle.downColor": "#f5395e", // Bearish candles (red)
            "mainSeriesProperties.candleStyle.borderUpColor": "#27b065", // Bullish border
            "mainSeriesProperties.candleStyle.borderDownColor": "#e65a5a", // Bearish border
            "mainSeriesProperties.candleStyle.wickUpColor": "#27b065", // Bullish wick
            "mainSeriesProperties.candleStyle.wickDownColor": "#e65a5a", // Bearish wick
            "mainSeriesProperties.candleStyle.barColorsOnPrevClose": false, // Disable bar color on close

            // Volume bar colors
            "volumePaneSize": "medium",
            "mainSeriesProperties.showPriceLine": true,
            "mainSeriesProperties.volumeStyle.volumeColor0": "#e65a5a", // Bearish volume
            "mainSeriesProperties.volumeStyle.volumeColor1": "#27b065", // Bullish volume

            // Watermark (faded background logo or text)
            "paneProperties.legendProperties.showStudyArguments": true,
            "paneProperties.legendProperties.showStudyTitles": false,
            "paneProperties.legendProperties.showStudyValues": false,
            "paneProperties.legendProperties.showSeriesTitle": true,
            "paneProperties.legendProperties.showSeriesOHLC": true,

            // Tooltip background
            "tooltip.borderColor": "#4d5057",
            "tooltip.backgroundColor": "#1e2026",
            "tooltip.textColor": "#a5a8ad",
        },
        layout: {
            backgroundColor: "#1e2026",
            textColor: "#a5a8ad",
            fontFamily: "'Trebuchet MS', sans-serif",
            fontSize: 12,
            gridLineColor: "#2b2f36"
        },
        studies: [
            {
                id: "ROC@tv-basicstudies",
                inputs: {
                    length: 14
                }
            }
        ],
        // Properly structured settings
        settings: {
            background: "#110f14",
            lineColor: "#2b2f36",
            textColor: "#a5a8ad"
        },
        // Proper structure for styles
        style: "1",
        charts: [{
            layout: {
                backgroundColor: "#1e2026",
                textColor: "#a5a8ad",
                fontFamily: "'Trebuchet MS', sans-serif",
                fontSize: 12,
                gridLineColor: "#2b2f36"
            }
        }]
    });

    // Instead of onChartReady, use this:
    if (typeof widget.onready === 'function') {
        widget.onready(() => {
            // Chart is ready
            console.log('Chart ready for', fullSymbol);
    });
    }
};
    
    // Handle script loading error
    script.onerror = () => {
        console.error('Failed to load TradingView script');
        chartContainer.innerHTML = 'Error loading chart components. Please check your internet connection.';
    };
    
    document.body.appendChild(script);
}

        function ConditionLetter(props) {
        return React.createElement('span', {
            className: 'condition-letter',
            style: {
            color: props.color,
            fontSize: '0.7em',
            fontWeight: 'bold',
            marginLeft: '4px',
            position: 'relative',
            display: 'inline-block'
            },
            onMouseOver: (e) => e.target.querySelector('.tooltip').style.visibility = 'visible',
            onMouseOut: (e) => e.target.querySelector('.tooltip').style.visibility = 'hidden'
        }, [
            props.letter,
            React.createElement('span', {
            className: 'tooltip',
            style: {
                visibility: 'hidden',
                position: 'absolute',
                bottom: '100%',
                left: '50%',
                transform: 'translateX(-50%)',
                padding: '4px 8px',
                backgroundColor: '#333',
                color: 'white',
                fontSize: '12px',
                borderRadius: '4px',
                whiteSpace: 'nowrap',
                marginBottom: '4px',
                pointerEvents: 'none'
            }
            }, props.tooltip)
        ]);
        }

        function CryptoName(props) {
            const letters = [
                { key: 'S', color: '#FF6B6B', tooltip: 'RoC Spikes', check: props.conditions.roc_spikes },
                { key: 'T', color: '#4ECDC4', tooltip: 'Volume Trend', check: props.conditions.volume_trend },
                { key: 'A', color: '#FFD93D', tooltip: 'Above Average Volume', check: props.conditions.above_avg_volume },
                { key: 'V', color: '#95D1CC', tooltip: 'Increasing Volatility', check: props.conditions.increasing_volatility },
                { key: 'M', color: '#FF8FB1', tooltip: 'Recent Moves', check: props.conditions.recent_moves }
            ];

            const activeLetters = letters.filter(l => l.check);
            const hasAnyCondition = activeLetters.length > 0;

            return React.createElement('div', null, [
                React.createElement('a', {
                    href: `https://pro.kraken.com/app/trade/${props.name.toLowerCase()}-usd`,
                    target: '_blank',
                    className: 'crypto-title'
                }, props.name),
                React.createElement('div', { style: { marginTop: '2px' } },
                    hasAnyCondition ? 
                        activeLetters.map(l => 
                            React.createElement(ConditionLetter, {
                                key: l.key,
                                letter: l.key,
                                color: l.color,
                                tooltip: l.tooltip
                            })
                        ) :
                        React.createElement('span', {
                            style: {
                                color: '#808080',
                                fontSize: '0.7em',
                                fontWeight: 'bold'
                            }
                        }, '[ NO TREND ]')
                )
            ]);
        }

        function setButtonState(rowId, buttonType, state) {
            try {
                let buttons = [];
                
                // Handle 'all' case
                if (rowId.toLowerCase() === 'all') {
                    // Select all buttons of the specified type across all rows
                    switch (buttonType.toLowerCase()) {
                        case 'trade':
                            buttons = Array.from(document.querySelectorAll('button:not(.buy-btn):not(.sell-btn)'));
                            break;
                        case 'buy':
                            buttons = Array.from(document.querySelectorAll('.buy-btn'));
                            break;
                        case 'sell':
                            buttons = Array.from(document.querySelectorAll('.sell-btn'));
                            break;
                        default:
                            console.error(`Invalid button type: ${buttonType}`);
                            return false;
                    }
                } else {
                    // Original single row logic
                    const container = document.querySelector(`[data-row-id="${rowId}"]`);
                    if (!container) {
                        console.error(`Container not found for rowId: ${rowId}`);
                        return false;
                    }

                    // Find the specific button based on buttonType
                    let button;
                    switch (buttonType.toLowerCase()) {
                        case 'trade':
                            button = container.querySelector('button:not(.buy-btn):not(.sell-btn)');
                            break;
                        case 'buy':
                            button = container.querySelector('.buy-btn');
                            break;
                        case 'sell':
                            button = container.querySelector('.sell-btn');
                            break;
                        default:
                            console.error(`Invalid button type: ${buttonType}`);
                            return false;
                    }

                    if (!button) {
                        console.error(`Button ${buttonType} not found in row ${rowId}`);
                        return false;
                    }
                    
                    buttons = [button];
                }

                if (buttons.length === 0) {
                    console.error(`No buttons found for type: ${buttonType}`);
                    return false;
                }

                // Apply state to all found buttons
                buttons.forEach(button => {
                    if (state.toLowerCase() === 'disabled') {
                        button.disabled = true;
                        button.style.backgroundColor = '#bebebe';
                        button.style.cursor = 'not-allowed';
                        
                        // Store original background color for re-enabling
                        button.setAttribute('data-original-bg', button.style.backgroundColor);
                        
                        // Remove hover effects
                        button.onmouseover = null;
                        button.onmouseout = null;
                    } else if (state.toLowerCase() === 'enabled') {
                        button.disabled = false;
                        
                        // Restore appropriate background color based on button type
                        switch (buttonType.toLowerCase()) {
                            case 'trade':
                                if (button.classList.contains('cancel-button')) {
                                    button.style.backgroundColor = '#cd3331';
                                    button.onmouseover = () => button.style.backgroundColor = '#a62a28';
                                    button.onmouseout = () => button.style.backgroundColor = '#cd3331';
                                } else if (button.classList.contains('reset-button')) {
                                    button.style.backgroundColor = '#ff8c00';
                                    button.onmouseover = () => button.style.backgroundColor = '#e67e00';
                                    button.onmouseout = () => button.style.backgroundColor = '#ff8c00';
                                } else {
                                    button.style.backgroundColor = 'green';
                                    button.onmouseover = () => button.style.backgroundColor = 'darkgreen';
                                    button.onmouseout = () => button.style.backgroundColor = 'green';
                                }
                                break;
                            case 'buy':
                                button.style.backgroundColor = '#0077cc';
                                button.onmouseover = () => button.style.backgroundColor = '#005599';
                                button.onmouseout = () => button.style.backgroundColor = '#0077cc';
                                break;
                            case 'sell':
                                button.style.backgroundColor = '#f97316';
                                button.onmouseover = () => button.style.backgroundColor = '#ea580c';
                                button.onmouseout = () => button.style.backgroundColor = '#f97316';
                                break;
                        }
                        button.style.cursor = 'pointer';
                    } else {
                        console.error(`Invalid state: ${state}. Use 'enabled' or 'disabled'`);
                        return false;
                    }
                });

                return true;
            } catch (error) {
                console.error('Error in setButtonState:', error);
                return false;
            }
        }

        async function calculatePercentageWithFees(currentPrice, referencePrice, orderType, isBuy = false) {
            // Get current fee rates
            const feeRates = await getCurrentFeeRates();
            
            // Determine if this is a maker or taker order
            let feeRate;
            if (orderType === 'limit' || orderType === 'stop-limit') {
                feeRate = feeRates.maker / 100; // Convert percentage to decimal
            } else {
                feeRate = feeRates.taker / 100; // Convert percentage to decimal
            }
            
            let percentDiff;
            
            if (isBuy) {
                // For buy orders: We're buying at currentPrice + fee
                const effectiveBuyPrice = currentPrice * (1 + feeRate);
                percentDiff = ((currentPrice - referencePrice) / referencePrice) * 100;
            } else {
                // For sell orders: We're selling at currentPrice - fee
                // When buying: effective cost was referencePrice * (1 + buyFeeRate)
                // When selling: effective proceeds will be currentPrice * (1 - sellFeeRate)
                
                // For simplicity, assume same fee rate for buy and sell
                // In a real system, you might want to store the actual buy fee rate with the order
                const effectiveBuyPrice = referencePrice * (1 + feeRate);
                const effectiveSellPrice = currentPrice * (1 - feeRate);
                
                // Calculate net percentage gain/loss
                percentDiff = ((effectiveSellPrice - effectiveBuyPrice) / effectiveBuyPrice) * 100;
            }
            
            return percentDiff;
        }

        function trackSellOrderPCT(rowId) {
            if (!window.pctTrackers) window.pctTrackers = {};
            
            // Clear existing interval if any
            if (window.pctTrackers[rowId]) {
                clearInterval(window.pctTrackers[rowId]);
            }

            // Create new interval
            window.pctTrackers[rowId] = setInterval(async () => {
                try {
                    // Get current order state
                    const response = await fetch(`/order/status/${rowId}`);
                    const state = await response.json();

                    // Stop tracking if order is no longer active
                    if (!state || state.status !== "sell_open") {
                        clearInterval(window.pctTrackers[rowId]);
                        delete window.pctTrackers[rowId];
                        return;
                    }

                    // Check required values
                    if (!state.buy_fill_price) {
                        console.log("Missing buy_fill_price in state", state);
                        return;
                    }

                    // Get current price
                    const currentPrice = state.current_price || await getLatestPrice(state.pair);
                    if (!currentPrice) {
                        console.log("Could not get current price");
                        return;
                    }

                    // Determine order type
                    const orderType = state.sell_order_type || 'market'; // Default to market if not specified

                    // Calculate percentage with fees
                    const priceDiff = await calculatePercentageWithFees(
                        currentPrice, 
                        state.buy_fill_price, 
                        orderType,
                        false
                    );

                    // Update UI with current price difference
                    const container = document.querySelector(`[data-row-id="${rowId}"]`);
                    if (container) {
                        const buyOrderStatus = container.querySelector('.buyOrderStatus');
                        const defaultText = container.querySelector('.status-text');
                        if (buyOrderStatus) {
                            const sign = priceDiff >= 0 ? "+" : "";
                            buyOrderStatus.textContent = `Sell Order Open [${sign}${priceDiff.toFixed(2)}%]`;
                            buyOrderStatus.style.color = priceDiff >= 0 ? "green" : "red";
                            buyOrderStatus.style.display = 'inline';
                            if (defaultText) defaultText.style.display = 'none';
                            setButtonState(rowId, 'sell', 'enabled');
                            setButtonState(rowId, 'buy', 'disabled');
                        }
                    }

                } catch (err) {
                    console.error("PCT tracking error:", err);
                    clearInterval(window.pctTrackers[rowId]);
                    delete window.pctTrackers[rowId];
                }
            }, 3000);
        }

        // Helper function to get latest price (for cases where it's not in the state)
        async function getLatestPrice(pair) {
            try {
                const response = await fetch(`/api/current_price?pair=${pair}`);
                if (!response.ok) return null;
                const data = await response.json();
                return data.price;
            } catch (err) {
                console.error("Error fetching latest price:", err);
                return null;
            }
        }

        function updateTimer() {
            const now = Date.now();
            const elapsed = now - lastRefreshTimestamp;
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            document.getElementById('timer').textContent = 
                `${minutes}m ${seconds}s`;
        }
        setInterval(updateTimer, 1000);

        async function fetchCryptoNews() {
    let isComponentMounted = true;
    const selectedCryptos = Array.from(document.querySelectorAll('.crypto-title'))
        .map(el => el.textContent.trim().toUpperCase());

    console.log("Selected Cryptos:", selectedCryptos);
    if (!selectedCryptos.length) {
        document.getElementById("crypto-news-content").textContent = "No cryptos selected";
        return;
    }

    // Add click event listener to the news content
    const newsContent = document.getElementById("crypto-news-content");
    newsContent.style.cursor = 'pointer';
    newsContent.onclick = function() {
        const url = this.getAttribute('data-url');
        if (url) {
            window.open(url, '_blank');
        }
    };

    let newsUpdateInterval;

    async function fetchNews(page = 1) {
        try {
            // Using CoinGecko's free API
            const response = await fetch(
                `https://api.coingecko.com/api/v3/news?page=${page}`,
                {
                    headers: {
                        'Accept': 'application/json'
                    }
                }
            );
            
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            
            const data = await response.json();
            return data;
        } catch (error) {
            console.error('Error fetching news:', error);
            return { data: [] };
        }
    }

    async function updateNewsContent() {
        try {
            // Fetch first two pages of news for more variety
            const [page1, page2] = await Promise.all([
                fetchNews(1),
                fetchNews(2)
            ]);

            const allNews = [...(page1.data || []), ...(page2.data || [])];
            
            if (!allNews.length) {
                throw new Error('No news data available');
            }
            
            // First, try to find news specific to selected cryptocurrencies
            let news = allNews.filter(article => 
                selectedCryptos.some(crypto => {
                    const cryptoName = crypto.replace('USD', '');
                    const searchTerms = [
                        cryptoName,
                        `$${cryptoName}`,
                        cryptoName.toLowerCase(),
                        `$${cryptoName.toLowerCase()}`
                    ];
                    return searchTerms.some(term => 
                        (article.title || '').includes(term) ||
                        (article.description || '').includes(term) ||
                        (article.categories || []).some(cat => cat.includes(term))
                    );
                })
            ).map(article => ({
                title: article.title || 'Untitled',
                url: article.url || '#',
                priority: 1, // Higher priority for specific crypto news
                relevance: selectedCryptos.filter(crypto => 
                    (article.title || '').toUpperCase().includes(crypto.replace('USD', ''))
                ).length // Count how many selected cryptos are mentioned
            }))
            // Sort by relevance (number of mentioned cryptos) and then by date
            .sort((a, b) => b.relevance - a.relevance || new Date(b.date) - new Date(a.date));
            
            // If no specific news found, include general crypto news as fallback
            if (!news.length) {
                news = allNews
                    .map(article => ({
                        title: article.title || 'Untitled',
                        url: article.url || '#',
                        priority: 0, // Lower priority for general news
                        relevance: 0
                    }))
                    .sort(() => Math.random() - 0.5) // Randomize order of general news
                    .slice(0, 20);
            }

            // Sort by priority (specific crypto news first)
            news.sort((a, b) => b.priority - a.priority || b.relevance - a.relevance);
            
            if (!news.length) {
                if (isComponentMounted) {
                    document.getElementById("crypto-news-content").textContent = "No news available";
                }
                return;
            }

            let newsIndex = 0;
            
            if (newsUpdateInterval) {
                clearInterval(newsUpdateInterval);
            }

            function updateNews() {
                if (!isComponentMounted) return;

                const newsElement = document.getElementById("crypto-news-content");
                if (!newsElement) return;

                newsElement.classList.add('fade-out');
                
                setTimeout(() => {
                    if (!isComponentMounted) return;
                    
                    const currentNews = news[newsIndex];
                    newsElement.textContent = currentNews.title;
                    newsElement.setAttribute('data-url', currentNews.url);
                    newsElement.classList.remove('fade-out');
                    newsElement.classList.add('fade-in');
                    
                    // Add visual indicator for news type
                    newsElement.classList.toggle('specific-news', currentNews.priority === 1);
                    newsElement.classList.toggle('general-news', currentNews.priority === 0);
                    
                    newsIndex = (newsIndex + 1) % news.length;
                    
                    setTimeout(() => {
                        if (!isComponentMounted) return;
                        newsElement.classList.remove('fade-in');
                    }, 500);
                }, 500);
            }

            updateNews();
            newsUpdateInterval = setInterval(updateNews, 5000);

        } catch (error) {
            console.error("Error in updateNewsContent:", error);
            if (isComponentMounted) {
                document.getElementById("crypto-news-content").textContent = 
                    error.message === 'No news data available' 
                        ? "No news available at the moment" 
                        : "Error fetching news";
            }
        }
    }

    // Initial update
    await updateNewsContent();

    // Set up periodic news refresh (every 5 minutes)
    const newsRefreshInterval = setInterval(updateNewsContent, 300000);

    return function cleanup() {
        isComponentMounted = false;
        if (newsUpdateInterval) {
            clearInterval(newsUpdateInterval);
        }
        if (newsRefreshInterval) {
            clearInterval(newsRefreshInterval);
        }
    };
}

// Initialize news with cleanup handling
document.addEventListener("DOMContentLoaded", () => {
    let cleanup;
    setTimeout(async () => {
        cleanup = await fetchCryptoNews();
    }, 1000);

    window.addEventListener('beforeunload', () => {
        // Clear all intervals
        Object.values(orderPollingIntervals).forEach(clearInterval);
        Object.values(window.pctTrackers || {}).forEach(clearInterval);
    });

    window.addEventListener('unload', () => {
        if (cleanup) cleanup();
    });

    document.addEventListener('visibilitychange', async () => {
        if (document.hidden && cleanup) {
            cleanup();
        } else if (!document.hidden) {
            cleanup = await fetchCryptoNews();
        }
    });
});

        // Reuse the single-crypto logic from your existing "evalRoc"
        async function evalRocForContainer(container) {
    // Ensure we have a valid container
    if (!container || !container.querySelector) {
        console.error('Invalid container passed to evalRocForContainer');
        return;
    }

    // Find crypto name, handling different potential structures
    let cryptoName = "";
    const titleEl = container.querySelector('.crypto-title');
    
    if (titleEl) {
        cryptoName = titleEl.textContent.trim().toUpperCase();
        console.log("Found crypto name from .crypto-title:", cryptoName);
    } else {
        // Try alternative selectors
        const altTitleEl = container.querySelector('[id^="crypto-name-"]') || 
                         container.querySelector('[class*="crypto-name"]') ||
                         container.querySelector('a[href*="trade"]');
        
        if (altTitleEl) {
            cryptoName = altTitleEl.textContent.trim().toUpperCase();
            console.log("Found crypto name from alternative selector:", cryptoName);
        } else {
            // Get row ID and try to extract crypto name from it
            const rowId = container.getAttribute('data-row-id');
            if (rowId && order_states[rowId] && order_states[rowId].pair) {
                cryptoName = order_states[rowId].pair;
                console.log("Found crypto name from order states:", cryptoName);
            } else {
                console.warn('Could not find crypto title element, skipping ROC evaluation');
                return;
            }
        }
    }

    // CRITICAL: Validate the crypto name - check multiple error cases
    if (!cryptoName) {
        console.error('Empty crypto name in evalRocForContainer');
        return;
    }
    
    // Case 1: If it's just "USD", skip this evaluation
    if (cryptoName === "USD") {
        console.warn('Skipping ROC evaluation for USD alone');
        return;
    }
    
    // Case 2: If it already ends with USD, keep it as is
    if (!cryptoName.endsWith("USD")) {
        // Case 3: Otherwise, add USD to make it a proper pair
        cryptoName = cryptoName + "USD";
    }
    
    console.log("Final validated crypto pair for API call:", cryptoName);

    try {
        // Fetch ROC data with extended timeout and error handling
        console.log(`Fetching ROC data for ${cryptoName}...`);
        
        const resp = await Promise.race([
            fetch(`/api/eval_roc?pair=${cryptoName}`),
            new Promise((_, reject) => 
                setTimeout(() => reject(new Error('ROC fetch timeout')), 5000)
            )
        ]);

        if (!resp.ok) {
            console.error(`Failed API response for ${cryptoName}:`, resp.status);
            throw new Error(`Failed to fetch ROC for ${cryptoName}`);
        }

        const data = await resp.json();
        console.log(`ROC data received for ${cryptoName}:`, data);

        // Improved data validation
        if (!data || typeof data !== 'object') {
            console.warn(`Invalid ROC data for ${cryptoName}:`, data);
            return;
        }

        // Get current fee rates
        const feeRates = await getCurrentFeeRates();
        console.log(`Fee rates for ${cryptoName}: Maker ${feeRates.maker}%, Taker ${feeRates.taker}%`);

        // Check for specific properties, provide fallbacks
        const actualStopLossPercent = data.stop_loss_percent || 0.2;
        const actualTakeProfitPercent = data.take_profit_percent || 1.16;
        const minUSD = data.min_usd || 10; // Default minimum if not provided

        // Calculate fee-adjusted display values
        const displayStopLoss = actualStopLossPercent + feeRates.taker;
        const displayTakeProfit = Math.max(0.1, actualTakeProfitPercent - feeRates.taker);

        // Find stop-loss and take-profit inputs
        const stopLossInput = container.querySelector('.stop-loss-input');
        const takeProfitInput = container.querySelector('.take-profit-input');

        // Validate inputs exist
        if (!stopLossInput || !takeProfitInput) {
            console.error('Stop-loss or take-profit input not found');
            return;
        }

        // Set stop-loss percentage (display adjusted)
        stopLossInput.value = displayStopLoss.toFixed(1);
        stopLossInput.setAttribute('data-actual-value', actualStopLossPercent.toFixed(1));
                    
        // Set take-profit percentage (display adjusted)
        takeProfitInput.value = displayTakeProfit.toFixed(1);
        takeProfitInput.setAttribute('data-actual-value', actualTakeProfitPercent.toFixed(1));

        // Handle minimum USD amount if applicable
        if (data.min_usd) {
            const amountInput = container.querySelector('input[type="number"]');
            if (amountInput) {
                // Set minimum amount if current value is less than minimum
                if (parseFloat(amountInput.value) < data.min_usd) {
                amountInput.value = data.min_usd;
                }
                
                amountInput.min = data.min_usd;
                
                // Style the label if it exists
                const amountLabel = amountInput.previousElementSibling;
                if (amountLabel) {
                amountLabel.innerHTML = '<span style="color: red; font-weight: bold; background: black; padding: 2px 4px;">MINIMUM</span>';
                }
                
                // Add change event listener if not already added
                if (!amountInput.hasAttribute('data-min-listener')) {
                    amountInput.setAttribute('data-min-listener', 'true');
                amountInput.addEventListener('change', function() {
                    if (parseFloat(this.value) < data.min_usd) {
                        this.value = data.min_usd;
                        alert(`This cryptocurrency requires a minimum order of $${data.min_usd}`);
                    }
                        // Trigger a refresh of the recommendations with fee adjustments
                        refreshRecommendedValues();
                });
                }
            }
        }
        } catch(err) {
        console.error("Eval error", err);
    }
}

        async function loadActiveOrders() {
    try {
        const response = await fetch('/api/active_orders');
        if (!response.ok) {
            const errorData = await response.json();
            console.error('Active orders error:', errorData);
            // Handle specific error cases
            if (response.status === 500) {
              await initializeButtonStates(); // Fallback to button initialization
              return;
            }
            throw new Error(errorData.error || 'Failed to fetch active orders');
          }
        const data = await response.json();
        
        if (!data.orders || !data.orders.length) {
            // If no active orders, initialize button states
            await initializeButtonStates();
            return;
        }
        
        const tableBody = document.getElementById('cryptoTableBody');
        
        for (const order of data.orders) {
            const basePair = order.pair.replace('USD', '');
            let row = Array.from(tableBody.rows).find(row => 
                row.querySelector('.crypto-title')?.textContent.trim() === basePair
            );
            
            // If crypto not in table, create new row
            if (!row) {
                row = await createNewRow(order);
                tableBody.appendChild(row);
            }

            // For sell orders, get the original buy price from history
            if (order.type === 'sell') {
                const buyPrice = await getBuyPriceFromHistory(order.pair, order.volume);
                if (buyPrice) {
                    // Store buy price in order state
                    const rowId = row.getAttribute('data-row-id');
                    if (!order_states[rowId]) {
                        order_states[rowId] = {};
                    }
                    order_states[rowId].buy_fill_price = buyPrice;
                }
            }
            
            // Update row status
            updateRowWithOrderStatus(row, order);

            // Start price tracking if it's a sell order
            if (order.type === 'sell') {
                const rowId = row.getAttribute('data-row-id');
                trackSellOrderPCT(rowId);
            }
        }
    } catch (error) {
        console.error('Error loading active orders:', error);
        await initializeButtonStates();
    }
}

        async function toggleResults() {
            const content = document.querySelector('.results-content');
            const arrow = document.querySelector('.down-arrow');
            
            // Toggle the open class
            content.classList.toggle('open');
            arrow.classList.toggle('open');
            
            // If we're opening the panel or it's already open, refresh the data
            if (content.classList.contains('open')) {
                await refreshTransactionHistory();
            }
        }

        async function refreshTransactionHistory() {
    try {
        const response = await fetch('/api/transaction_history');
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const transactions = await response.json();
        
        const tbody = document.getElementById('transactionTableBody');
        if (!tbody) return;
        
        tbody.innerHTML = '';
        
        // Define monthNames array
        const monthNames = [
            "January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"
        ];
        
        // Helper function to format datetime without seconds and add AM/PM
        function formatTime(dateStr) {
            const [datePart, timePart] = dateStr.split(' ');
            if (!timePart) return datePart;
            
            const [hours, minutes] = timePart.split(':');
            const hour = parseInt(hours);
            const ampm = hour >= 12 ? 'PM' : 'AM';
            const hour12 = hour % 12 || 12; // Convert 0 to 12 for 12 AM
            
            return `${datePart} ${hour12}:${minutes} ${ampm}`;
        }
        
        // Group by day first
        const days = {};
        transactions.forEach(transaction => {
            const datePart = transaction.date.split(' ')[0];
            
            if (!days[datePart]) {
                days[datePart] = [];
            }
            
            days[datePart].push(transaction);
        });
        
        // Then group days by month
        const months = {};
        Object.entries(days).forEach(([dateKey, dayTransactions]) => {
            const dateParts = dateKey.split('-');
            const monthKey = `${dateParts[0]}-${dateParts[1]}`;
            
            if (!months[monthKey]) {
                months[monthKey] = {
                    name: `${monthNames[parseInt(dateParts[1]) - 1]} ${dateParts[0]}`,
                    days: {},
                    total: 0,
                    count: 0
                };
            }
            
            months[monthKey].days[dateKey] = dayTransactions;
            dayTransactions.forEach(tx => {
                months[monthKey].total += tx.percentage;
                months[monthKey].count++;
            });
        });

        // Render months - sorted by string comparison (newest first)
        Object.entries(months)
            .sort((a, b) => b[0].localeCompare(a[0]))
            .forEach(([monthKey, monthData]) => {
                // CHANGE: Use total instead of average
                const totalGain = monthData.total;
                const gainClass = totalGain >= 0 ? 'positive-gain' : 'negative-gain';
                
                // Month row - Changed "avgGain" to "totalGain" in the display
                const monthRow = document.createElement('tr');
                monthRow.className = 'daily-row';
                monthRow.onclick = () => toggleMonthDetails(monthKey);
                monthRow.innerHTML = `
                    <td>
                        <span class="day-arrow" id="arrow-month-${monthKey}">â–¶</span>
                        ${monthData.name}
                    </td>
                    <td class="${gainClass}">
                        ${totalGain >= 0 ? '+' : ''}${totalGain.toFixed(2)}%
                    </td>
                    <td class="trades-count">${monthData.count} trades</td>
                `;
                tbody.appendChild(monthRow);
                
                // Create month details container
                const monthDetails = document.createElement('tr');
                monthDetails.className = 'transaction-details month-details';
                monthDetails.id = `month-details-${monthKey}`;
                const monthCell = document.createElement('td');
                monthCell.colSpan = 3;
                
                // Days table
                const daysTable = document.createElement('table');
                daysTable.style.width = '100%';
                
                // Render days - sorted by string comparison (newest first)
                Object.entries(monthData.days)
                    .sort((a, b) => b[0].localeCompare(a[0]))
                    .forEach(([dateKey, dayTransactions]) => {
                        // CHANGE: Calculate total instead of average for days
                        const dayTotal = dayTransactions.reduce((sum, t) => sum + t.percentage, 0);
                        const dayClass = dayTotal >= 0 ? 'positive-gain' : 'negative-gain';
                        
                        // Create day row
                        const dayRow = document.createElement('tr');
                        dayRow.className = 'daily-row';
                        dayRow.onclick = (e) => {
                            e.stopPropagation();
                            toggleDayDetails(dateKey);
                        };
                        
                        // Format the date with just month and day
                        const dateParts = dateKey.split('-');
                        const monthIndex = parseInt(dateParts[1]) - 1;
                        const monthName = monthNames[monthIndex].substring(0, 3);
                        const formattedDate = `${monthName} ${dateParts[2]}, ${dateParts[0]}`;

                        dayRow.innerHTML = `
                            <td>
                                <span class="day-arrow" id="arrow-${dateKey}">â–¶</span>
                                ${formattedDate}
                            </td>
                            <td class="${dayClass}">
                                ${dayTotal >= 0 ? '+' : ''}${dayTotal.toFixed(2)}%
                            </td>
                            <td class="trades-count">${dayTransactions.length} trades</td>
                        `;
                        daysTable.appendChild(dayRow);
                        
                        // Create day details row
                        const dayDetails = document.createElement('tr');
                        dayDetails.className = 'transaction-details day-details';
                        dayDetails.id = `details-${dateKey}`;
                        
                        const dayCell = document.createElement('td');
                        dayCell.colSpan = 3;
                        
                        const tradesTable = document.createElement('table');
                        tradesTable.style.width = '100%';
                        tradesTable.innerHTML = `
                            <tr class="detail-row" style="font-weight: bold;">
                                <td>Time</td>
                                <td>Crypto</td>
                                <td>Buy Total</td>
                                <td>Sell Total</td>
                                <td>Volume</td>
                                <td>Fees</td>
                                <td>Gain/Loss</td>
                            </tr>
                        `;
                        
                        // Sort the day's transactions by time (newest first)
                        dayTransactions
                            .sort((a, b) => {
                                const aTime = a.date.split(' ')[1] || '';
                                const bTime = b.date.split(' ')[1] || '';
                                return bTime.localeCompare(aTime);
                            })
                            .forEach(trade => {
                                const tradeRow = document.createElement('tr');
                                tradeRow.className = 'detail-row';
                                
                                // Format time to remove seconds and add AM/PM
                                const formattedTime = formatTime(trade.date).split(' ').slice(1).join(' ');
                                
                                // Calculate buy and sell totals
                                const buyTotal = trade.buy_price * trade.volume;
                                const sellTotal = trade.sell_price * trade.volume;
                                
                                // Calculate total fees
                                const totalFees = trade.total_fees_usd || 0;
                                
                                // Add fee info tooltip
                                const feeTooltip = `
                                    Buy Fee: $${trade.buy_fee_usd?.toFixed(2) || '0.00'}<br>
                                    Sell Fee: $${trade.sell_fee_usd?.toFixed(2) || '0.00'}<br>
                                    Total: $${totalFees.toFixed(2)}
                                `;
                                
                                // Calculate net gain/loss percentage
                                const sellAfterFees = sellTotal - totalFees;
                                const netPercentage = buyTotal > 0 ? ((sellAfterFees - buyTotal) / buyTotal) * 100 : 0;
                                
                                tradeRow.innerHTML = `
                                    <td>${formattedTime}</td>
                                    <td>${trade.crypto}</td>
                                    <td>$${buyTotal.toFixed(2)}</td>
                                    <td>$${sellTotal.toFixed(2)}</td>
                                    <td>${trade.volume.toFixed(8)}</td>
                                    <td class="fee-info">
                                        $${totalFees.toFixed(2)}
                                        <span class="tooltip">${feeTooltip}</span>
                                    </td>
                                    <td class="${netPercentage >= 0 ? 'positive-gain' : 'negative-gain'}">
                                        ${netPercentage >= 0 ? '+' : ''}${netPercentage.toFixed(2)}%
                                    </td>
                                `;
                                tradesTable.appendChild(tradeRow);
                            });
                        
                        dayCell.appendChild(tradesTable);
                        dayDetails.appendChild(dayCell);
                        daysTable.appendChild(dayDetails);
                    });
                
                monthCell.appendChild(daysTable);
                monthDetails.appendChild(monthCell);
                tbody.appendChild(monthDetails);
            });
    } catch (error) {
        console.error('Error refreshing transaction history:', error);
        const tbody = document.getElementById('transactionTableBody');
        if (tbody) {
            tbody.innerHTML = `<tr><td colspan="3">Error loading transaction history: ${error.message}</td></tr>`;
        }
    }
}

function toggleMonthDetails(monthKey) {
const allMonthDetails = document.querySelectorAll('.month-details');
const allMonthArrows = document.querySelectorAll('[id^="arrow-month-"]');
const currentDetails = document.getElementById(`month-details-${monthKey}`);
const currentArrow = document.getElementById(`arrow-month-${monthKey}`);

// Hide all day details
document.querySelectorAll('.day-details').forEach(detail => {
    detail.classList.remove('open');
    detail.style.display = 'none';
});
document.querySelectorAll('[id^="arrow-"]').forEach(arrow => {
    if (!arrow.id.startsWith('arrow-month-')) {
        arrow.classList.remove('open');
    }
});

// Hide other month details
allMonthDetails.forEach(detail => {
    if (detail !== currentDetails) {
        detail.classList.remove('open');
        detail.style.display = 'none';
    }
});

// Reset other month arrows
allMonthArrows.forEach(arrow => {
    if (arrow !== currentArrow) {
        arrow.classList.remove('open');
    }
});

// Toggle current month
if (!currentDetails.classList.contains('open')) {
    currentDetails.style.display = 'table-row';
    setTimeout(() => currentDetails.classList.add('open'), 10);
} else {
    currentDetails.classList.remove('open');
    setTimeout(() => currentDetails.style.display = 'none', 200);
}

currentArrow.classList.toggle('open');
}

        async function createNewRow(order) {
            const tr = document.createElement('tr');
            tr.setAttribute('data-row-id', `row-${order.order_id}`);
            
            // Fetch crypto details for the new row
            try {
                const response = await fetch(`/api/crypto_details?pair=${order.pair}`);
                const details = await response.json();
                
                tr.innerHTML = `
                    <td>
                        <div style="display: flex; align-items: center; height: 100%;">
                            <div style="width: 30px; display: flex; align-items: center; justify-content: center;">
                                <span class="chart-expander" style="cursor: pointer; transition: transform 0.3s ease;" onclick="toggleCryptoChart(this)">â–¶</span>
                            </div>
                            <div style="flex-grow: 1;">
                                <a href="https://pro.kraken.com/app/trade/${order.pair.toLowerCase()}" target="_blank" class="crypto-title">${order.pair.replace('USD', '')}</a>
                            </div>
                        </div>
                    </td>
                    <td>$${order.current_price.toFixed(4)}</td>
                    <td>${details.avg_roc}%</td>
                    <td>${details.roc_activity}</td>
                    <td>$${(details.volume / 1_000_000).toFixed(1)}M</td>
                    <td>${details.one_percent_gain}</td>
                    <td>${details.high_low}</td>
                    <td class="trade-cell">
                        <!-- Trade controls -->
                        <div style="display: flex; align-items: center;">
                            <div>
                                <label style="font-size: 0.8em;">Loss %</label><br>
                                <input type="text" class="stop-loss-input" style="width: 4ch;">
                            </div>
                            <div>
                                <label style="font-size: 0.8em;">Profit %</label><br>
                                <input type="text" class="take-profit-input" style="width: 4ch;">
                            </div>
                            <div>
                                <label style="font-size: 0.8em;">Amount</label><br>
                                <input type="number" value="20" style="width: 10ch;">
                            </div>
                            <button class="cancel-button" onclick="cancelOrder(this)">Cancel</button>
                            <button
                                class="buy-btn"
                                onmouseover="this.style.backgroundColor='#005599';"
                                onmouseout="this.style.backgroundColor='#0077cc';"
                                onclick="marketBuy(this)"
                            >
                                Buy
                            </button>
                            <button
                                class="sell-btn"
                                onclick="marketSell(this)"
                            >
                                Sell
                            </button>
                            <div class="status-container" style="align-self: flex-end; height: 30px; display: flex; align-items: center;">
                                <div class="polling-dot"></div>
                                <span class="buyOrderStatus" style="display: none;"></span>
                                <span class="status-text">Inactive</span>
                            </div>
                        </div>
                    </td>
                `;
            } catch (error) {
                console.error('Error creating new row:', error);
            }
            
            return tr;
        }

        async function updateRowWithOrderStatus(row, order) {
            const button = row.querySelector('button');
            const statusDiv = row.querySelector('.buyOrderStatus');
            const defaultText = row.querySelector('.status-text');
            
            if (defaultText) defaultText.style.display = 'none';
            if (statusDiv) {
                statusDiv.style.display = 'inline';
                const sign = order.price_diff >= 0 ? '+' : '';
                
                if (order.type === 'buy') {
                    statusDiv.textContent = `Buy Order Open [${sign}${order.price_diff.toFixed(2)}%]`;
                    statusDiv.style.color = 'yellow';
                    if (marketBuyBtn) {
                        marketBuyBtn.style.backgroundColor = '#0077cc';
                    }
                } else {
                    statusDiv.textContent = `Sell Order Open [${sign}${order.price_diff.toFixed(2)}%]`;
                    statusDiv.style.color = order.price_diff >= 0 ? 'green' : 'red';
                    setButtonState(rowId, 'sell', 'enabled');
                    setButtonState(rowId, 'buy', 'disabled');
                }
            }
            
            if (button) {
                button.textContent = 'Cancel';
                button.classList.add('cancel-button');
                button.onclick = () => cancelOrder(button);
            }
            
            // Start status polling
            const rowId = row.getAttribute('data-row-id');
            startOrderStatusPolling(rowId, row);
        }


        // Overwrite your existing evalRoc button handler
        async function evalRoc(button) {
            const container = button.closest('tr') || button.closest('.crypto-item');
            if (!container) return;
            await evalRocForContainer(container);
        }

        // async function checkOrderStatus(rowId) {
        //     try {
        //         const response = await fetch(`/order/status/${rowId}`);
        //         if (!response.ok) {
        //             throw new Error('Failed to fetch order status');
        //         }
        //         const state = await response.json();
        //         return state.status;
        //     } catch (error) {
        //         console.error('Error checking order status:', error);
        //         throw error;
        //     }
        // }

        function findContainer(rowId) {
            if (!rowId) {
                console.warn("No rowId provided to findContainer");
                return null;
            }
            
            // Try multiple strategies to find the container
            let container = null;
            
            // Strategy 1: direct data-row-id match
            container = document.querySelector(`[data-row-id="${rowId}"]`);
            if (container) return container;
            
            // Strategy 2: fuzzy match (case insensitive or with prefixes)
            const allRowContainers = document.querySelectorAll('[data-row-id]');
            for (const candidate of allRowContainers) {
                const candidateId = candidate.getAttribute('data-row-id');
                if (candidateId.toLowerCase() === rowId.toLowerCase() || 
                    candidateId.includes(rowId) || 
                    rowId.includes(candidateId)) {
                    return candidate;
                }
            }
            
            // Strategy 3: find by ID component 
            if (rowId.includes('-')) {
                const idParts = rowId.split('-');
                const numericPart = idParts[idParts.length - 1];
                
                // Try to find by numeric ID
                if (!isNaN(numericPart)) {
                    container = document.querySelector(`[data-row-id$="-${numericPart}"]`);
                    if (container) return container;
                    
                    // Try to find by index
                    const rows = document.querySelectorAll('#cryptoTableBody tr');
                    if (rows.length > numericPart) {
                        return rows[numericPart];
                    }
                }
            }
            
            // Strategy 4: find element that contains the order ID somewhere
            const orderIdMatch = rowId.match(/row-([a-zA-Z0-9]+)/);
            if (orderIdMatch && orderIdMatch[1]) {
                const orderId = orderIdMatch[1];
                container = document.querySelector(`[id*="${orderId}"], [data-order-id*="${orderId}"]`);
                if (container) return container;
            }
            
            // Fallback: get first row if it's the only one with active state
            if (Object.keys(order_states).length === 1) {
                const rows = document.querySelectorAll('#cryptoTableBody tr');
                if (rows.length === 1) {
                    console.log("Using fallback - only one table row found");
                    return rows[0];
                }
            }
            
            console.error(`Container for rowId '${rowId}' not found after all attempts`);
            return null;
        }

// Function to update input fields to show adjusted values
function updateFeeAdjustedInputs(feeRates) {
    // Get all stop-loss and take-profit inputs
    const rows = document.querySelectorAll('[data-row-id]');
    
    rows.forEach(row => {
        const stopLossInput = row.querySelector('.stop-loss-input');
        const takeProfitInput = row.querySelector('.take-profit-input');
        
        if (stopLossInput) {
            updateStopLossDisplay(stopLossInput, feeRates.taker);
        }
        
        if (takeProfitInput) {
            updateTakeProfitDisplay(takeProfitInput, feeRates.taker);
        }
    });
}

// Function to update stop-loss input display
function updateStopLossDisplay(input, takerFee) {
    const container = input.closest('div');
    const originalValue = parseFloat(input.value);
    
    if (isNaN(originalValue) || originalValue <= 0) return;
    
    // Calculate adjusted value
    const adjustedValue = Math.max(0.1, originalValue - takerFee);
}

// Function to update take-profit input display
function updateTakeProfitDisplay(input, takerFee) {
    const container = input.closest('div');
    const originalValue = parseFloat(input.value);
    
    if (isNaN(originalValue) || originalValue <= 0) return;
    
    // Calculate adjusted value
    const adjustedValue = originalValue + takerFee;
}

async function applyFeeAdjustedValues() {
  console.log('Applying fee-adjusted values...');
  
  try {
    // Get current fee rates once for all calculations
    const feeRates = await getCurrentFeeRates();
    console.log(`Current fee rates - Maker: ${feeRates.maker}%, Taker: ${feeRates.taker}%`);
    
    // Process all rows in the table
    const rows = document.querySelectorAll('#cryptoTableBody tr');
    console.log(`Processing ${rows.length} rows for fee adjustments`);
    
    const stopLossMode = document.getElementById('stopLossSelect')?.value || 'recommended';
    const takeProfitMode = document.getElementById('takeProfitSelect')?.value || 'recommended';
    
    for (const row of rows) {
      // Check for valid crypto title
      const titleEl = row.querySelector('.crypto-title');
      if (!titleEl || titleEl.textContent.trim() === 'USD') {
        continue;
      }
      
      const cryptoName = titleEl.textContent.trim().toUpperCase() + "USD";
      const stopLossInput = row.querySelector('.stop-loss-input');
      const takeProfitInput = row.querySelector('.take-profit-input');
      
      if (!stopLossInput || !takeProfitInput) continue;
      
      // Get existing values
      const stopLossValue = parseFloat(stopLossInput.value) || 0.2;
      const takeProfitValue = parseFloat(takeProfitInput.value) || 1.16;
      
      // Apply fee adjustments
      // For stop-loss: actual = display - fee (store actual in data attribute)
      const actualStopLoss = Math.max(0.1, stopLossValue - feeRates.taker);
      stopLossInput.setAttribute('data-actual-value', actualStopLoss.toFixed(1));
      
      // For take-profit: actual = display + fee (store actual in data attribute)
      const actualTakeProfit = takeProfitValue + feeRates.taker;
      takeProfitInput.setAttribute('data-actual-value', actualTakeProfit.toFixed(1));
      
      console.log(`${cryptoName}: Stop Loss ${stopLossValue}% â†’ ${actualStopLoss.toFixed(1)}%, Take Profit ${takeProfitValue}% â†’ ${actualTakeProfit.toFixed(1)}%`);
    }
    
    console.log('Fee adjustments applied successfully');
    return true;
  } catch (error) {
    console.error('Error applying fee adjustments:', error);
    return false;
  }
}

// Set up event listeners for inputs
async function setupFeeAdjustedInputListeners(feeRates) {
    document.querySelectorAll('.stop-loss-input').forEach(input => {
      input.addEventListener('change', async function() {
        try {
          // Get current fee rates
          const feeRates = await getCurrentFeeRates();
          
          // Get display value (what user entered)
          const displayValue = parseFloat(this.value);
          if (isNaN(displayValue)) return;
          
          // Calculate actual value (what will be sent to API)
          const actualValue = Math.max(0.1, displayValue - feeRates.taker);
          
          // Store actual value and mark as fee-adjusted
          this.setAttribute('data-actual-value', actualValue.toFixed(1));
          this.setAttribute('data-fee-adjusted', 'true');
          
          console.log(`Stop-loss adjusted: Display ${displayValue}% â†’ Actual ${actualValue.toFixed(1)}%`);
        } catch (error) {
          console.error('Error adjusting stop-loss for fees:', error);
        }
      });
      
      // Initialize with current value
      const feeRates = getCurrentFeeRates();
      updateStopLossDisplay(input, feeRates.taker);
    });
    
    document.querySelectorAll('.take-profit-input').forEach(input => {
      input.addEventListener('change', async function() {
        try {
          // Get current fee rates
          const feeRates = await getCurrentFeeRates();
          
          // Get display value (what user entered)
          const displayValue = parseFloat(this.value);
          if (isNaN(displayValue)) return;
          
          // Calculate actual value (what will be sent to API)
          const actualValue = displayValue + feeRates.taker;
          
          // Store actual value and mark as fee-adjusted
          this.setAttribute('data-actual-value', actualValue.toFixed(1));
          this.setAttribute('data-fee-adjusted', 'true');
          
          console.log(`Take-profit adjusted: Display ${displayValue}% â†’ Actual ${actualValue.toFixed(1)}%`);
        } catch (error) {
          console.error('Error adjusting take-profit for fees:', error);
        }
      });
      
      // Initialize with current value
      updateTakeProfitDisplay(input, feeRates.taker);
    });
    
    console.log('Set up improved fee-adjusted input listeners');
  }

function startOrderStatusPolling(rowId, container) {
    if (orderPollingIntervals[rowId]) {
        clearInterval(orderPollingIntervals[rowId]);
    }

    const marketSellBtn = container.querySelector('.sell-btn');
    const marketBuyBtn = container.querySelector('.buy-btn');
    const statusDiv = container.querySelector(".buyOrderStatus");
    const defaultText = container.querySelector('.status-text');
    const cancelButton = container.querySelector('.cancel-button');
    const pollingDot = container.querySelector('.polling-dot');

    let errorRetryCount = 0;
    const MAX_ERROR_RETRIES = 3;

    updateAutoRefreshVisibility(true);
    
    orderPollingIntervals[rowId] = setInterval(async () => {
        // Skip polling if we're in a transitional state
        if (container.getAttribute('data-transitioning') === 'true') {
            return;
        }

        try {
            const state = await retryStatusCheck(rowId);
            errorRetryCount = 0;

            // Skip status update if we entered a transitional state while fetching
            if (container.getAttribute('data-transitioning') === 'true') {
                return;
            }

            // Handle completion immediately
            if (state.status === "completed") {
                // NEW CODE: Try to get the accurate percentage from Kraken
                try {
                    const tradeDataResp = await fetch('/api/get_recent_trade', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pair: state.pair,
                            volume: state.filled_volume
                        })
                    });
                    
                    if (tradeDataResp.ok) {
                        const tradeData = await tradeDataResp.json();
                    
                        // Use the accurate percentage
                        const displayPercentage = tradeData.netPercentage;
                        console.log("Got accurate percentage from Kraken:", displayPercentage);
                
                // Update UI
                if (statusDiv) {
                    const sign = displayPercentage >= 0 ? "+" : "";
                    statusDiv.textContent = `Trade Completed [${sign}${displayPercentage.toFixed(2)}%]`;
                    statusDiv.style.color = displayPercentage >= 0 ? "green" : "red";
                    statusDiv.style.display = 'inline';
                }
                if (defaultText) defaultText.style.display = 'none';
                    
                        // Update state
                        if (typeof order_states !== 'undefined' && rowId in order_states) {
                            order_states[rowId].percent_gain = displayPercentage;
                        }
                        
                if (pollingDot) pollingDot.style.display = 'none';

                // Update cancel button
                const cancelButton = container.querySelector('.cancel-button');
                if (cancelButton) {
                    cancelButton.textContent = "Reset";
                    cancelButton.style.backgroundColor = "#ff8c00";
                    cancelButton.classList.add("reset-button");
                }

                // Reset button states
                setButtonState(rowId, 'sell', 'disabled');
                setButtonState(rowId, 'buy', 'enabled');

                // Clear intervals
                clearInterval(orderPollingIntervals[rowId]);
                delete orderPollingIntervals[rowId];
                if (window.pctTrackers && window.pctTrackers[rowId]) {
                    clearInterval(window.pctTrackers[rowId]);
                    delete window.pctTrackers[rowId];
                }

                updateAutoRefreshVisibility(false);
                return;
            }
        } catch (error) {
            console.error("Error getting accurate percentage:", error);
        }
            }
            if (statusDiv) {
                if (state.status === "buy_open") {
                    // Determine order type for fee calculation
                    const orderType = state.buy_order_type || 'limit'; // Default to limit for buy orders
                    
                    // Calculate percentage with fees for buy order
                    let priceDiff;
                    if (state.current_price && state.buy_price) {
                        priceDiff = await calculatePercentageWithFees(
                            state.current_price, 
                            state.buy_price, 
                            orderType,
                            true
                        );
                    } else {
                        priceDiff = state.buy_price_diff || 0;
                    }
                    
                    const sign = priceDiff >= 0 ? "+" : "";
                    statusDiv.textContent = `Buy Order Open [${sign}${priceDiff.toFixed(2)}%]`;
                    statusDiv.style.color = "yellow";
                    
                    // Update polling dot for buy order
                    if (pollingDot) {
                        pollingDot.style.display = 'block';
                        pollingDot.style.backgroundColor = 'yellow';
                    }
                } else if (state.status === "sell_open") {
                    // Determine order type for fee calculation
                    const orderType = state.sell_order_type || 'stop-loss'; // Default to stop-loss for sell orders
                    
                    // Calculate percentage with fees for sell order
                    let priceDiff;
                    if (state.current_price && state.buy_fill_price) {
                        priceDiff = await calculatePercentageWithFees(
                            state.current_price, 
                            state.buy_fill_price, 
                            orderType,
                            false
                        );
                    } else {
                        priceDiff = state.current_price_diff || 0;
                    }
                    
                    const sign = priceDiff >= 0 ? "+" : "";

                    // Log take-profit monitoring
                    if (state.take_profit) {
                        console.log(`\nMonitoring take-profit for ${rowId}:`);
                        console.log(`Current gain: ${priceDiff.toFixed(2)}%`);
                        console.log(`Take-profit target: ${state.take_profit}%`);
                    }

                    if (statusDiv.textContent.includes("Selling at")) {
                        statusDiv.style.color = "yellow";
                        // Update polling dot for selling
                        if (pollingDot) {
                            pollingDot.style.display = 'block';
                            pollingDot.style.backgroundColor = 'yellow';
                        }
                    } else {
                        statusDiv.textContent = `Sell Order Open [${sign}${priceDiff.toFixed(2)}%]`;
                        setButtonState(rowId, 'sell', 'enabled');
                        setButtonState(rowId, 'buy', 'disabled');
                        statusDiv.style.color = priceDiff >= 0 ? "green" : "red";
                        if (pollingDot) {
                            pollingDot.style.display = 'block';
                            pollingDot.style.backgroundColor = priceDiff >= 0 ? "green" : "red";
                        }
                    }
        
                    // Check if this is a stop-loss order
        const orderDetails = await retryStatusCheck(rowId);
        const isStopLoss = orderDetails?.order_info?.descr?.ordertype === 'stop-loss';
                    
                    statusDiv.style.display = 'inline';
                    if (defaultText) defaultText.style.display = 'none';
                }
            }

            // Update the rest of the UI
            state.row_id = rowId; 
            updateOrderStatus(state, null, null);

        } catch (err) {
            // Skip error handling if we're in a transitional state
            if (container.getAttribute('data-transitioning') === 'true') {
                return;
            }

            console.error(`Status polling error for ${rowId}:`, err);
            errorRetryCount++;
            
            if (errorRetryCount <= MAX_ERROR_RETRIES) {
                if (statusDiv) {
                    statusDiv.textContent = `Checking status... (retry ${errorRetryCount}/${MAX_ERROR_RETRIES})`;
                    statusDiv.style.color = "yellow";
                    // Show yellow polling dot during retries
                    if (pollingDot) {
                        pollingDot.style.display = 'block';
                        pollingDot.style.backgroundColor = 'yellow';
                    }
                }
            } else {
                if (statusDiv) {
                    statusDiv.textContent = "Error checking status";
                    statusDiv.style.color = "red";
                    if (pollingDot) pollingDot.style.display = 'none';
                }
                clearInterval(orderPollingIntervals[rowId]);
                delete orderPollingIntervals[rowId];
            }
        }
    }, 5000);
}

async function retryOrderOnCancel(state, container) {
    const maxRetries = 5;
    const retryDelay = 2000;
    const statusDiv = container.querySelector(".buyOrderStatus");

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            statusDiv.textContent = `Retrying order... (${attempt}/${maxRetries})`;
            statusDiv.style.color = "yellow";

            // Try market buy instead of limit
            const response = await fetch("/order/market_buy", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ row_id: state.row_id })
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || "Failed to place market buy");
            }

            // Success - exit retry loop
            return true;

        } catch (error) {
            console.error(`Retry attempt ${attempt} failed:`, error);
            if (attempt === maxRetries) {
                statusDiv.textContent = "Max retries reached - click Trade to try again";
                statusDiv.style.color = "red";
                return false;
            }
            await new Promise(resolve => setTimeout(resolve, retryDelay));
        }
    }
    return false;
}

function cleanupPollingDot(rowId) {
    console.log(`Starting cleanup for rowId: ${rowId}`);

    // Find all potential containers
    const containers = [
        document.querySelector(`[data-row-id="${rowId}"]`),
        document.querySelector(`tr[data-row-id="${rowId}"]`),
        document.querySelector(`.crypto-item[data-row-id="${rowId}"]`),
        document.getElementById(rowId)
    ].filter(Boolean); // Remove null/undefined entries

    if (containers.length === 0) {
        console.log(`No containers found for rowId: ${rowId}`);
    } else {
        console.log(`Found ${containers.length} containers for rowId: ${rowId}`);
    }

    containers.forEach(container => {
        const dots = container.querySelectorAll('.polling-dot');
        if (dots.length === 0) {
            console.log(`No polling dots found in container for rowId: ${rowId}`);
        } else {
            console.log(`Found ${dots.length} polling dots in container for rowId: ${rowId}`);
        }

        dots.forEach(dot => {
            // First disable animations and make it invisible
            dot.style.animation = 'none';
            dot.style.display = 'none';
            dot.style.visibility = 'hidden';
            dot.style.opacity = '0';
            dot.classList.remove('pulse');
            dot.style.backgroundColor = 'transparent';
            dot.remove();
            console.log(`Polling dot cleaned up for rowId: ${rowId}`);
        });
    });

    // Also cleanup any associated intervals
    if (orderPollingIntervals[rowId]) {
        clearInterval(orderPollingIntervals[rowId]);
        delete orderPollingIntervals[rowId];
        console.log(`Cleared order polling interval for rowId: ${rowId}`);
    } else {
        console.log(`No order polling interval found for rowId: ${rowId}`);
    }

    if (window.pctTrackers && window.pctTrackers[rowId]) {
        clearInterval(window.pctTrackers[rowId]);
        delete window.pctTrackers[rowId];
        console.log(`Cleared PCT tracker interval for rowId: ${rowId}`);
    } else {
        console.log(`No PCT tracker interval found for rowId: ${rowId}`);
    }
}

// Function to refresh displayed values based on current fee rates
async function refreshFeeAdjustedValues() {
    const feeRates = await getCurrentFeeRates();
    console.log(`Current fee rates - Maker: ${feeRates.maker}%, Taker: ${feeRates.taker}%`);
    
    // Get all stop-loss and take-profit inputs
    const stopLossInputs = document.querySelectorAll('.stop-loss-input');
    const takeProfitInputs = document.querySelectorAll('.take-profit-input');
}

/**
 * Calculates the display value for stop-loss, adding fees for UI display
 * @param {number} actualStopLossPercent - The actual stop-loss percentage to be used in orders
 * @param {Object} feeRates - Object containing maker and taker fee rates
 * @returns {number} Display-adjusted stop-loss percentage
 */
 async function calculateDisplayStopLoss(actualStopLossPercent) {
    // Get current fee rates
    const feeRates = await getCurrentFeeRates();
    
    // For stop-loss display, we ADD the fee to show what the user will actually lose
    // We use taker fee since stop-loss typically executes as market orders
    const displayStopLoss = actualStopLossPercent + feeRates.taker;
    
    console.log(`Display stop-loss adjustment: Actual ${actualStopLossPercent}% â†’ Display ${displayStopLoss.toFixed(2)}% (Fee: ${feeRates.taker}%)`);
    
    return displayStopLoss;
}

/**
 * Calculates the display value for take-profit, subtracting fees for UI display
 * @param {number} actualTakeProfitPercent - The actual take-profit percentage to be used in orders
 * @param {Object} feeRates - Object containing maker and taker fee rates
 * @returns {number} Display-adjusted take-profit percentage
 */
async function calculateDisplayTakeProfit(actualTakeProfitPercent) {
    // Get current fee rates
    const feeRates = await getCurrentFeeRates();
    
    // For take-profit display, we SUBTRACT the fee to show what the user will actually gain
    // We use taker fee for both buy and sell since market orders are common
    const displayTakeProfit = actualTakeProfitPercent - feeRates.taker;
    
    console.log(`Display take-profit adjustment: Actual ${actualTakeProfitPercent}% â†’ Display ${displayTakeProfit.toFixed(2)}% (Fee: ${feeRates.taker}%)`);
    
    return displayTakeProfit;
}

/**
 * Updates the order status in the UI based on the current state of the order.
 * 
 * @param {Object} state - The current state of the order.
 * @param {HTMLElement} statusDiv - The HTML element where the status is displayed.
 * @param {HTMLElement} button - The button element associated with the order.
 * @param {string} kraken_status - The status of the order from Kraken.
 * @param {Object} order_info - Additional information about the order.
 */
 async function updateOrderStatus(state, statusDiv, button, kraken_status, order_info) {

// Find status container and polling dot
let container = button?.closest('tr') || statusDiv?.closest('tr') || button?.closest('.crypto-item') || statusDiv?.closest('.crypto-item');

if (!container) {
console.log("Initial container find failed");
    // Only attempt fallback if we have a valid row_id.
    if (state.row_id) {
        let potentialContainers = [
            statusDiv?.parentElement,
            statusDiv?.parentElement?.parentElement,
            document.querySelector(`[data-row-id="${state.row_id}"]`),
            document.querySelector(`tr[data-row-id="${state.row_id}"]`),
            document.querySelector(`.crypto-item[data-row-id="${state.row_id}"]`)
        ];
        for (let potential of potentialContainers) {
            if (potential) {
                console.log("Found container through fallback");
                container = potential;
                break;
            }
        }
    } else {
        console.error("State.row_id is undefined, cannot find container.");
        return state;
    }
    
    if (!container) {
        console.error("No container found for row_id:", state.row_id);
        return state;
    }
}

const pollingDot = container.querySelector('.polling-dot');

// First, check if we need to handle a closed stop-loss order (key fix for fee calculation)
if (kraken_status === "closed" && state.status === "sell_open" && order_info) {
    // Stop-loss order was executed
    if ("stopprice" in order_info && parseFloat(order_info["stopprice"]) > 0) {
        console.log(`DEBUG: Stop-loss order ${state.sell_order_id} executed at ${order_info.price}`);

        try {
            // Get current fee rates for accurate percentage calculation
            const feeRates = await getCurrentFeeRates();
            
            const buy_price = state.buy_fill_price;
            const sell_price = parseFloat(order_info.price);
            
            // Calculate the net percentage with fees
            const takerFee = feeRates.taker / 100; // Convert to decimal
            const effectiveBuyPrice = buy_price * (1 + takerFee);
            const effectiveSellPrice = sell_price * (1 - takerFee);
            const percent_gain = ((effectiveSellPrice - effectiveBuyPrice) / effectiveBuyPrice) * 100;

            console.log(`Fee-adjusted calculation: Buy ${buy_price}, Sell ${sell_price}`);
            console.log(`Effective Buy ${effectiveBuyPrice}, Effective Sell ${effectiveSellPrice}`);
            console.log(`Net percentage with fees: ${percent_gain.toFixed(2)}%`);

            // Record transaction and mark trade as completed
            const crypto_name = state.pair.replace("USD", "");
            if (record_completed_trade(state, sell_price, buy_price, crypto_name)) {
                console.log(`Trade completed: ${crypto_name} sold at ${sell_price}, Gain/Loss: ${percent_gain.toFixed(2)}%`);
            }

            // Update state with the net percentage
            state.sell_order_id = null;
            state.status = "completed";
            state.percent_gain = Math.round(percent_gain * 100) / 100; // Round to 2 decimal places

            state.history.push({
                "timestamp": Date.now() / 1000,
                "status": "stop_loss_completed",
                "sell_price": sell_price,
                "percent_gain": percent_gain
            });

            // If the polling dot exists, hide it
            if (pollingDot) {
                pollingDot.style.display = 'none';
                pollingDot.remove();
            }
            
            return state;  // Return early with updated state
        } catch (error) {
            console.error("Error calculating fee-adjusted percentage:", error);
            // Continue with normal processing if fee calculation fails
        }
    }
}

// If the trade is completed, remove the polling dot
if (state.status === "completed" && pollingDot) {
    pollingDot.style.display = 'none';
    pollingDot.remove();
    return state;
}

// Helper function to update dot state
const updateDot = (show, color) => {
    if (pollingDot) {
        pollingDot.style.display = show ? 'block' : 'none';
        if (show) {
            pollingDot.style.backgroundColor = color;
        }
    }
};

const defaultText = container.querySelector('.status-text');
const marketSellBtn = container.querySelector('.sell-btn');
const marketBuyBtn = container.querySelector('.buy-btn');

if (defaultText) defaultText.style.display = 'none';

// Check if a stop-loss sell order is open**
const hasStopLossOrder = state.status === "sell_open";

// Check if a buy order was filled (user has crypto balance)**
const cryptoBalance = state.filled_volume || 0;
const hasCrypto = cryptoBalance > 0;

// Check if there is no active order at all**
const noOrderOpen = !hasStopLossOrder && state.status !== "buy_filled";

// Ensure the SELL button is disabled on page load if no trade is open**
if (marketSellBtn) {
const cryptoName = container.querySelector('.crypto-title').textContent.trim();
// Check current balance and orders from Kraken
const accountResponse = await fetch('/api/check_account');
const accountData = await accountResponse.json();

const cryptoBalance = accountData.balances.find(b => b.name === cryptoName);
const hasBalance = cryptoBalance && cryptoBalance.quantity > 0;

// Check if there's an open sell order of any type (including stop-loss)
const openSellOrder = accountData.orders.find(o => 
    o.name === cryptoName && 
    o.order.toLowerCase().includes('sell') &&
    !o.status.toLowerCase().includes('canceled')
);
}

// Get or create buyOrderStatus span if it doesn't exist
let buyOrderStatus = container.querySelector('.buyOrderStatus');
if (!buyOrderStatus) {
    buyOrderStatus = document.createElement('span');
    buyOrderStatus.className = 'buyOrderStatus';
    statusDiv.parentElement.insertBefore(buyOrderStatus, defaultText);
}
buyOrderStatus.style.display = 'inline';

function setResetButton(button) {
    button.textContent = "Reset";
    button.style.backgroundColor = "#ff8c00";  // Orange color
    button.classList.add("reset-button");
    button.onmouseover = () => button.style.backgroundColor = "#e67e00";
    button.onmouseout = () => button.style.backgroundColor = "#ff8c00";
}

switch (state.status) {
    case "buy_open":
        //const rowId = container.getAttribute('data-row-id');
        const priceDiff = state.buy_price_diff || 0;
        const sign = priceDiff >= 0 ? '+' : '';
        
        // Always show Buy Now button and update its style
        if (marketBuyBtn) {
            marketBuyBtn.style.backgroundColor = '#0077cc';
        }
        
        if (kraken_status === "canceled") {
            // Handle canceled order
            const cancelReason = order_info.get("reason");
            if (cancelReason === "Post only order") {
                console.log("Post only order cancelled, retrying as market buy");
                // Try retrying with market buy

                    const retryResp = await fetch("/order/market_buy", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ 
                        row_id: rowId,
                        pair: state.pair,
                        usd_amount: state.usd_amount,
                        sell_percent: state.sell_percent,
                        take_profit: state.take_profit
                    })
                });

                if (!retryResp.ok) {
                    state.status = "cancelled";
                    state.history.push({  // Changed from append
                        timestamp: Date.now() / 1000,
                        status: "cancelled",
                        reason: "Market buy retry failed"
                    });
                    
                    // Reset UI
                    buyOrderStatus.style.display = "none";
                    if (defaultText) defaultText.style.display = "inline";
                    resetTradeButton(button);
                }
            } else if (cancelReason === "Insufficient funds") {
                state.status = "cancelled";
                state.history.push({  // Changed from append
                    timestamp: Date.now() / 1000,
                    status: "cancelled",
                    reason: "Insufficient funds"
                });
                
                // Reset UI
                buyOrderStatus.style.display = "none";
                if (defaultText) defaultText.style.display = "inline";
                resetTradeButton(button);
            } else {
                state.status = "cancelled";
                state.history.push({  // Changed from append to push to fix bug
                    timestamp: Date.now() / 1000,
                    status: "cancelled",
                    reason: cancelReason || "Unknown"
                });
                
                // Reset UI
                buyOrderStatus.style.display = "none";
                if (defaultText) defaultText.style.display = "inline";
                resetTradeButton(button);
            }
            return state;
        } else if (kraken_status === "closed") {
            // Buy order is filled
            const vol_exec = parseFloat(order_info.vol_exec);
            if (vol_exec > 0) {
                const fill_price = parseFloat(order_info.price);
                state.status = "buy_filled";
                state.filled_volume = vol_exec;
                state.buy_fill_price = fill_price;
                
                // Update UI
                buyOrderStatus.textContent = "Sending Sell Order...";
                buyOrderStatus.style.color = "yellow";
                updateDot(true, "yellow");

                // Automatically place stop-loss sell order
                const sellInput = container.querySelector('.stop-loss-input');
                const sellPercent = sellInput ? parseFloat(sellInput.value) : 0;
                
                if (sellPercent) {
                    fetch("/order/stop_loss_sell", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            row_id: rowId,
                            sell_percent: sellPercent
                        })
                    }).catch(err => console.error("Error placing stop-loss:", err));
                }
                
                // Add to history
                state.history.push({
                    timestamp: Date.now() / 1000,
                    status: "buy_filled",
                    price: fill_price,
                    volume: vol_exec
                });
            }
        } else if (kraken_status === "open") {
            // Order still open, show tracking
            if (buyOrderStatus.textContent === "Opening Buy Order...") {
                const pctSpan = document.createElement('span');
                pctSpan.id = `pct-${rowId}`;
                buyOrderStatus.textContent = 'Buy Order Open [';
                buyOrderStatus.appendChild(pctSpan);
                buyOrderStatus.appendChild(document.createTextNode(']'));
                // Start tracking immediately
                trackBuyOrderPCT(rowId, state.buy_price);
            }
            buyOrderStatus.style.color = "yellow";
            updateDot(true, "yellow");

            // Check price movement
            if (order_info.descr && order_info.descr.price) {
                const limit_price = parseFloat(order_info.descr.price);
                const price_diff_pct = ((current_price - limit_price) / limit_price) * 100;
                state.buy_price_diff = price_diff_pct;
                buyOrderStatus.textContent = `Buy Order Open [${sign}${price_diff_pct.toFixed(2)}%]`;
            }
        }
        break;

    case "buy_filled":
        buyOrderStatus.textContent = "Sending Sell Order...";
        buyOrderStatus.style.color = "yellow";
        updateDot(true, "yellow");

        // Store filled details
        if (state.vol_exec) {
            state.filled_volume = parseFloat(state.vol_exec);
        }
        if (state.price) {
            state.buy_fill_price = parseFloat(state.price);
        }

        // Automatically place stop-loss sell order
        const sellPercent = container.querySelector('.stop-loss-input')?.value;
        if (sellPercent) {
            fetch("/order/stop_loss_sell", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    row_id: state.row_id,
                    sell_percent: parseFloat(sellPercent)
                })
            }).catch(err => console.error("Error placing stop-loss:", err));
        }
        break;

        case "sell_open":
            const percentDiff = state.current_price_diff || 0;
            const sellSign = percentDiff >= 0 ? "+" : "";
        const rowId = container.getAttribute('data-row-id');
            
            console.log('DEBUG - Order Info:', {
                fullOrderInfo: order_info,
                descr: order_info?.descr,
                orderType: order_info?.descr?.ordertype
            });
            
            const orderType = order_info?.descr?.ordertype;
            console.log('DEBUG - Determined Order Type:', orderType);
            
            // Check if market sell button exists
            console.log('DEBUG - Market Sell Button exists:', !!marketSellBtn);
            console.log('DEBUG - order_info:', order_info);
            console.log('DEBUG - orderType:', order_info?.descr?.ordertype);

            
            if (orderType === "stop-loss") {
                console.log('DEBUG - Detected stop-loss order');
    // Add specific handling for stop-loss orders
            } else if (orderType === "limit") {
                console.log('DEBUG - Detected limit order');
            } else {
                console.log('DEBUG - Unknown order type:', orderType);
                console.log('DEBUG - Full order info for unknown type:', order_info);
            }

            // Update status text
            buyOrderStatus.textContent = `Sell Order Open [${sellSign}${percentDiff.toFixed(2)}%]`;
            setButtonState(rowId, 'sell', 'enabled');
            setButtonState(rowId, 'buy', 'disabled');
            buyOrderStatus.style.color = percentDiff >= 0 ? "green" : "red";
            const dotColor = percentDiff >= 0 ? "green" : "red";
            updateDot(true, dotColor);

            // Add take-profit check here
            const takeProfitInput = container.querySelector('.take-profit-input');
            const takeProfitValue = takeProfitInput ? parseFloat(takeProfitInput.value) : 0;

            // Check if take profit has been reached
            if (takeProfitValue > 0 && percentDiff >= takeProfitValue) {
                try {
                    // Instead of canceling and placing new order, edit existing order
                    const result = await fetch("/order/update_stop_loss", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            row_id: rowId,
                            order_id: state.sell_order_id,
                            stop_loss_percent: 0  // Set to 0 to trigger immediate sell
                        })
                    });

                    if (!result.ok) {
                        throw new Error("Failed to update stop-loss for take profit");
                    }

                    statusDiv.textContent = `Take Profit Triggered [${percentDiff.toFixed(2)}%]`;
                    statusDiv.style.color = "green";

                } catch (error) {
                    console.error("Error executing take profit:", error);
                    statusDiv.textContent = `Error: ${error.message}`;
                    statusDiv.style.color = "red";
                }
            }

            if (kraken_status === "closed") {
            // Sell order completed
            const sell_price = parseFloat(order_info.price);
            const buy_price = state.buy_fill_price;
            
            // IMPROVED: Calculate final gain/loss with fees
            try {
                // Get current fee rates for accurate percentage calculation
                const feeRates = await getCurrentFeeRates();
                
                // Calculate the net percentage with fees
                const takerFee = feeRates.taker / 100; // Convert to decimal
                const effectiveBuyPrice = buy_price * (1 + takerFee);
                const effectiveSellPrice = sell_price * (1 - takerFee);
                const percent_gain = ((effectiveSellPrice - effectiveBuyPrice) / effectiveBuyPrice) * 100;
            const sign = percent_gain >= 0 ? "+" : "";

                console.log(`Fee-adjusted calculation: Buy ${buy_price}, Sell ${sell_price}`);
                console.log(`Effective Buy ${effectiveBuyPrice}, Effective Sell ${effectiveSellPrice}`);
                console.log(`Net percentage with fees: ${percent_gain.toFixed(2)}%`);

            // Update status to show completed trade with final percentage
                if (statusDiv) {
            statusDiv.textContent = `Trade Completed [${sign}${percent_gain.toFixed(2)}%]`;
            setButtonState(rowId, 'sell', 'disabled');
            setButtonState(rowId, 'buy', 'enabled');
            statusDiv.style.color = percent_gain >= 0 ? "green" : "red";
                }
                
                // Update state with the fee-adjusted percentage
                state.percent_gain = Math.round(percent_gain * 100) / 100;
                
            } catch (error) {
                console.error("Error calculating fee-adjusted percentage:", error);
                // Fall back to simple percentage calculation if fee calculation fails
                const simple_percent_gain = ((sell_price - buy_price) / buy_price) * 100;
                const simple_sign = simple_percent_gain >= 0 ? "+" : "";
                
                if (statusDiv) {
                    statusDiv.textContent = `Trade Completed [${simple_sign}${simple_percent_gain.toFixed(2)}%]`;
                    setButtonState(rowId, 'sell', 'disabled');
                    setButtonState(rowId, 'buy', 'enabled');
                    statusDiv.style.color = simple_percent_gain >= 0 ? "green" : "red";
                }
                
                state.percent_gain = Math.round(simple_percent_gain * 100) / 100;
            }
            
            cleanupPollingDot(rowId);
            
            // Change Cancel button to Reset button
            const cancelButton = button?.closest('tr')?.querySelector('.cancel-button');
            if (cancelButton) {
                cancelButton.textContent = "Reset";
                cancelButton.style.backgroundColor = "#ff8c00";  // Orange color
                cancelButton.classList.add("reset-button");
                cancelButton.onmouseover = () => cancelButton.style.backgroundColor = "#e67e00";
                cancelButton.onmouseout = () => cancelButton.style.backgroundColor = "#ff8c00";
            }

            // Stop both polling and tracking
            if (orderPollingIntervals[rowId]) {
                clearInterval(orderPollingIntervals[rowId]);
                delete orderPollingIntervals[rowId];
            }
            if (window.pctTrackers && window.pctTrackers[rowId]) {
                clearInterval(window.pctTrackers[rowId]);
                delete window.pctTrackers[rowId];
            }
            
            updateAutoRefreshVisibility(false); 
            return state;  // Exit early - no need to try placing another stop-loss
        }
            
            // Start or update PCT tracking
            if (!window.pctTrackers || !window.pctTrackers[state.row_id]) {
                trackSellOrderPCT(state.row_id);
            }

            // Check for take profit trigger
            if (state.take_profit && percentDiff >= state.take_profit) {
                marketSell(marketSellBtn);
                buyOrderStatus.textContent = `Take Profit Triggered [${sellSign}${percentDiff.toFixed(2)}%]`;
            } else {
                buyOrderStatus.textContent = `Sell Order Open [${sellSign}${percentDiff.toFixed(2)}%]`;
                setButtonState(rowId, 'sell', 'enabled');
                setButtonState(rowId, 'buy', 'disabled');

                // Check if we need to renew stop-loss
                const sellInput = container.querySelector('.stop-loss-input');
                const newSellPercent = parseFloat(sellInput?.value || 0);
                const renewalThreshold = newSellPercent / 2;

                if (percentDiff >= renewalThreshold && state.sell_order_id) {
                    // Cancel current stop-loss and place new one
                    fetch("/order/cancel", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ row_id: state.row_id })
                    })
                    .then(() => {
                        return fetch("/order/stop_loss_sell", {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                row_id: state.row_id,
                                sell_percent: newSellPercent
                            })
                        });
                    })
                    .catch(err => console.error("Error renewing stop-loss:", err));
                }
            }

            buyOrderStatus.style.color = percentDiff >= 0 ? "green" : "red";
            buyOrderStatus.style.display = 'inline';
        break;

    case "cancelled":
    case "canceled":
    if (state.percent_gain !== undefined) {
            // If we have percent_gain, this was a completed trade
            const gainSign = state.percent_gain >= 0 ? "+" : "";
            buyOrderStatus.textContent = `Trade Completed [${gainSign}${state.percent_gain.toFixed(2)}%]`;
            setButtonState(rowId, 'sell', 'disabled');
            setButtonState(rowId, 'buy', 'enabled');
            buyOrderStatus.style.color = state.percent_gain >= 0 ? "green" : "red";
            cleanupPollingDot(rowId);
            setResetButton(button);
            const cancelButton = container.querySelector('.cancel-button');
            if (cancelButton) {
                cancelButton.textContent = "Reset";
                cancelButton.style.backgroundColor = "#ff8c00";
                cancelButton.classList.add("reset-button");
            }
        } else {
            // Regular cancellation
            if (buyOrderStatus) {
                buyOrderStatus.textContent = `Order Cancelled${state.reason ? ': ' + state.reason : ''}`;
                buyOrderStatus.style.color = "grey";
                if (button) resetTradeButton(button);
            }
        }

        // Remove the polling dot
        if (pollingDot) {
            pollingDot.style.display = "none";
        }

        if (buyOrderStatus && defaultText) {
            setTimeout(() => {
                buyOrderStatus.style.display = "none";
                defaultText.style.display = 'inline';
            }, 3000);
        }
        if (state.row_id) {
            clearInterval(orderPollingIntervals[state.row_id]);
            delete orderPollingIntervals[state.row_id];
        }
        updateAutoRefreshVisibility(false);
        break;

    case "completed":
        let displayPercentage = null;

        // First try to get accurate percentage from Kraken
        try {
            const tradeDataResp = await fetch('/api/get_recent_trade', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    pair: state.pair,
                    volume: state.filled_volume
                })
            });
            
            if (tradeDataResp.ok) {
                const tradeData = await tradeDataResp.json();
                displayPercentage = tradeData.netPercentage;
                console.log("Got accurate percentage for completed trade:", displayPercentage);
            }
        } catch (error) {
            console.error("Error getting accurate percentage:", error);
        }
        
        if (displayPercentage === null) {
            // IMPROVED: Calculate percentage with fees if we have prices
            if (state.buy_fill_price && state.final_price) {
                try {
                    // Get current fee rates
                    const feeRates = await getCurrentFeeRates();
                    
                    // Calculate effective prices with fees
                    const buyPrice = state.buy_fill_price;
                    const sellPrice = state.final_price;
                    const takerFee = feeRates.taker / 100; // Convert to decimal
                    
                    const effectiveBuyPrice = buyPrice * (1 + takerFee);
                    const effectiveSellPrice = sellPrice * (1 - takerFee);
                    
                    // Calculate net percentage with fees
                    displayPercentage = ((effectiveSellPrice - effectiveBuyPrice) / effectiveBuyPrice) * 100;
                    
                    console.log(`Manual calculation: Buy ${buyPrice}, Sell ${sellPrice}`);
                    console.log(`Effective Buy ${effectiveBuyPrice}, Effective Sell ${effectiveSellPrice}`);
                    console.log(`Net percentage with fees: ${displayPercentage.toFixed(2)}%`);
                } catch (error) {
                    console.error("Error calculating fee-adjusted percentage:", error);
                }
            }
            
            // If fee calculation failed, check previously stored values
        if (displayPercentage === null) {
            // First priority: Check if we stored the percentage in the order state
            if (state.captured_percentage !== undefined) {
                displayPercentage = state.captured_percentage;
            } 
            // Second priority: Check if there's a final_percentage stored
            else if (state.final_percentage !== undefined) {
                displayPercentage = state.final_percentage;
            }
            // Third priority: Use percent_gain from the state
            else if (state.percent_gain !== undefined) {
                displayPercentage = state.percent_gain;
                }
            }
        }
        
        if (displayPercentage !== null) {
            const sign = displayPercentage >= 0 ? "+" : "";
        if (statusDiv) {
                statusDiv.textContent = `Trade Completed [${sign}${displayPercentage.toFixed(2)}%]`;
                setButtonState(rowId, 'sell', 'disabled');
                setButtonState(rowId, 'buy', 'enabled');
                statusDiv.style.color = displayPercentage >= 0 ? "green" : "red";
                statusDiv.style.display = 'inline';
            }
        } else {
            // Fallback to standard completion display
            const sign = state.percent_gain >= 0 ? "+" : "";
            if (statusDiv) {
            statusDiv.textContent = `Trade Completed [${sign}${state.percent_gain.toFixed(2)}%]`;
                setButtonState(rowId, 'sell', 'disabled');
                setButtonState(rowId, 'buy', 'enabled');
            statusDiv.style.color = state.percent_gain >= 0 ? "green" : "red";
            statusDiv.style.display = 'inline';
        }
        }
        
        // Remove the polling dot
        if (pollingDot) {
            pollingDot.style.display = 'none';
        }
        
        // Update cancel button to reset
        const cancelButton = container.querySelector('.cancel-button');
        if (cancelButton) {
            cancelButton.textContent = "Reset";
            cancelButton.style.backgroundColor = "#ff8c00";
            cancelButton.classList.add("reset-button");
        }
        
        // Clear all intervals
        if (orderPollingIntervals[rowId]) {
            clearInterval(orderPollingIntervals[rowId]);
            delete orderPollingIntervals[rowId];
        }
        if (window.pctTrackers && window.pctTrackers[rowId]) {
            clearInterval(window.pctTrackers[rowId]);
            delete window.pctTrackers[rowId];
        }
        
        // Re-enable auto-refresh
        updateAutoRefreshVisibility(false);
        break;

    case "error":
        buyOrderStatus.textContent = `Error: ${state.error || "Unknown error"}`;
        buyOrderStatus.style.color = "red";
        resetTradeButton(button);
        clearInterval(orderPollingIntervals[state.row_id]);
        break;

    default:
        // Handle unexpected or undefined statuses
        buyOrderStatus.textContent = `Unknown status: ${state.status}`;
        buyOrderStatus.style.color = "grey";
        resetTradeButton(button);
        break;
}

return state;
}

        function sortTable(columnIndex) {
            const table = document.getElementById("cryptoTable");
            const rows = Array.from(table.rows).slice(1); // Exclude header row

            if (currentSortColumn === columnIndex) {
                currentSortOrder = currentSortOrder === "asc" ? "desc" : "asc";
            } else {
                currentSortOrder = "asc";
                currentSortColumn = columnIndex;
            }

            rows.sort((rowA, rowB) => {
                let cellA = rowA.cells[columnIndex].textContent.trim();
                let cellB = rowB.cells[columnIndex].textContent.trim();
                
                // Remove trend arrows if present (for Average RoC column)
                cellA = cellA.replace(/[â–²â–¼-]/, '').trim();
                cellB = cellB.replace(/[â–²â–¼-]/, '').trim();
                
                cellA = cellA.replace(/[$,%M]/g, '');
                cellB = cellB.replace(/[$,%M]/g, '');
                
                const numA = parseFloat(cellA);
                const numB = parseFloat(cellB);

                let comparison = 0;
                if (!isNaN(numA) && !isNaN(numB)) {
                    comparison = numA - numB;
                } else {
                    comparison = cellA.localeCompare(cellB);
                }
                return currentSortOrder === "asc" ? comparison : -comparison;
            });

            const tbody = table.querySelector("tbody");
            rows.forEach(row => tbody.appendChild(row));
            updateArrows(columnIndex);
        }

        function updateArrows(activeColumn) {
            const headers = document.querySelectorAll("th");
            headers.forEach((header, index) => {
                const upArrow = header.querySelector(".arrow-up");
                const downArrow = header.querySelector(".arrow-down");
                if (index === activeColumn) {
                    if (currentSortOrder === "asc") {
                        if (upArrow) upArrow.style.display = "inline";
                        if (downArrow) downArrow.style.display = "none";
                    } else {
                        if (upArrow) upArrow.style.display = "none";
                        if (downArrow) downArrow.style.display = "inline";
                    }
                } else {
                    if (upArrow) upArrow.style.display = "none";
                    if (downArrow) downArrow.style.display = "none";
                }
            });
        }

        const orderPollingIntervals = {};
        
        // Set to track order IDs that are being processed
        const pendingOrders = new Set();

        async function placeTrailingStopBuy(button) {
    const container = button.closest("tr") || button.closest(".crypto-item");
    if (!container) return;

    const rowId = container.getAttribute("data-row-id");
    const statusDiv = container.querySelector(".buyOrderStatus");
    const defaultText = container.querySelector('.status-text');
    const takeProfitInput = container.querySelector('.take-profit-input');
    const takeProfitValue = takeProfitInput ? parseFloat(takeProfitInput.value) : 0;

    if (!rowId) {
        console.error("Missing rowId");
        alert("Order cannot be processed due to missing rowId.");
        return;
    }

try {
// Get the pair from the row
const titleEl = container.querySelector('.crypto-title');
const cryptoName = titleEl.textContent.trim();
const pair = cryptoName + "USD";

        // Check for active orders
const statusText = statusDiv?.textContent || "";
let hasActiveOrder = statusText !== "Inactive" && !statusText.includes("Cancelled");

if (hasActiveOrder) {
    // Verify with Kraken
    const response = await fetch('/api/check_account');
    const data = await response.json();
    
    if (data.error) {
        throw new Error(data.error);
    }

        const activeOrderForPair = data.orders?.some(order => 
        order.name === cryptoName && 
        !order.status.toLowerCase().includes('canceled') && 
        !order.status.toLowerCase().includes('cancelled')
    ) || false;

        hasActiveOrder = activeOrderForPair;
        }

// Handle take profit update for active orders
if (hasActiveOrder) {
            if (button.textContent === "Trade") {
                try {
                    const resp = await fetch("/order/update_take_profit", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            row_id: rowId,
                            take_profit: takeProfitValue
                        })
                    });

                    if (!resp.ok) {
                        const data = await resp.json();
                        throw new Error(data.error || "Failed to update take profit");
                    }

                    alert("Take Profit updated successfully");
                    return;
                } catch (err) {
                    console.error("Take Profit update failed:", err);
                    alert(`Failed to update Take Profit: ${err.message}`);
    return;
    }
}
            return;
        }

        // Place new order
if (pendingOrders.has(rowId)) {
    console.log(`Order for ${rowId} is already being processed`);
    alert("This order is already being processed. Please wait.");
    return;
}

try {
    pendingOrders.add(rowId);
    button.disabled = true;
    button.textContent = "Placing...";
    button.style.backgroundColor = "grey";

    const amountInput = container.querySelector('input[type="number"]');
    const textInputs = container.querySelectorAll('input[type="text"]');
    const usdAmount = parseFloat(amountInput?.value || "0");
    const sellPercent = parseFloat(textInputs[0]?.value || "0");

    if (isNaN(sellPercent) || isNaN(usdAmount) || usdAmount <= 0) {
        alert("Please ensure all inputs are valid and the USD amount is greater than 0.");
        resetTradeButton(button);
        return;
    }

    const resp = await fetch("/order/trailing_stop_buy", {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
            "X-Request-ID": `${rowId}-${Date.now()}`
        },
        body: JSON.stringify({
            row_id: rowId,
            pair: pair,
            usd_amount: usdAmount,
            sell_percent: sellPercent,
            take_profit: takeProfitValue
        })
    });

    const data = await resp.json();

            if (data.status === "restricted") {
                alert(data.error);
                resetTradeButton(button);
                return;
            }

    if (!resp.ok) {
        throw new Error(data.error || "Failed to place order");
    }

    // Update UI for successful order placement
    button.textContent = "Cancel";
    button.classList.add("cancel-button");
    button.disabled = false;
    button.onclick = () => cancelOrder(button);
    button.onmouseover = () => button.style.backgroundColor = "#a62a28";
    button.onmouseout = () => button.style.backgroundColor = "#cd3331";

    if (defaultText) defaultText.style.display = 'none';
    if (statusDiv) {
        statusDiv.style.display = 'inline';
        statusDiv.textContent = "Buy Order Open";
        statusDiv.style.color = "yellow";
    }

    startOrderStatusPolling(rowId, container);

} finally {
    pendingOrders.delete(rowId);
}

} catch (error) {
console.error("Order placement failed:", error);
        resetTradeButton(button);
        alert(error.message);
    }
}

        function resetTradeButton(button) {
            console.log("DEBUG: Reset button clicked");
            if (!button) return;

            if (!button) {
                console.log("DEBUG: No button provided");
                return;
            }
            
            // Get container
            const container = button.closest('tr') || button.closest('.crypto-item');
            if (!container) {
                console.log("DEBUG: No container found");
                return;
            }
            
            // Check if this is a reset button
            if (button.classList.contains('reset-button')) {
                console.log("DEBUG: Handling reset button");
                // Reset button to initial Trade state
                button.textContent = "Trade";
                button.style.backgroundColor = "rgb(0, 128, 0)";  // Original green color
                button.classList.remove("cancel-button", "reset-button");
                button.disabled = false;
                button.onclick = () => placeTrailingStopBuy(button);
                button.onmouseover = () => button.style.backgroundColor = "rgb(0, 100, 0)";
                button.onmouseout = () => button.style.backgroundColor = "rgb(0, 128, 0)";
                
                // Reset status display
                const statusDiv = container.querySelector('.buyOrderStatus');
                const defaultText = container.querySelector('.status-text');
                console.log("DEBUG: Found status elements:", {
                    statusDiv: !!statusDiv,
                    defaultText: !!defaultText
                });
                const marketSellBtn = container.querySelector('.sell-btn');
                const marketBuyBtn = container.querySelector('.buy-btn');
                
                if (statusDiv) {
                    statusDiv.style.display = 'none';
                    statusDiv.textContent = '';
                }
                if (defaultText) {
                    defaultText.style.display = 'inline';
                    defaultText.textContent = 'Inactive';
                    defaultText.style.color = '#666';  // Set to grey color
                }

                // Clear the row from order states
                const rowId = container.getAttribute('data-row-id');
                if (typeof order_states !== 'undefined' && rowId in order_states) {
                    delete order_states[rowId];
                }
                
                return;
            }
            
            // Normal button reset logic
            button.textContent = "Trade";
            button.style.backgroundColor = "rgb(0, 128, 0)";
            button.classList.remove("cancel-button");
            button.disabled = false;
            button.onclick = () => placeTrailingStopBuy(button);
            button.onmouseover = () => button.style.backgroundColor = "rgb(0, 100, 0)";
            button.onmouseout = () => button.style.backgroundColor = "rgb(0, 128, 0)";
            
            // Only reset the status display if it's not showing a completion percentage
            if (container) {
                const statusDiv = container.querySelector('.buyOrderStatus');
                const defaultText = statusDiv.parentElement.querySelector('.status-text');
                
                // Check if the status shows a percentage (completed trade)
                if (!statusDiv.textContent.includes('%') || statusDiv.textContent.includes('Order')) {
                    statusDiv.style.display = 'none';
                    defaultText.style.display = 'inline';
                }
            }
        }

        async function checkStatus(rowId, statusDiv, marketSellBtn, marketBuyBtn, cancelBtn) {
    try {
        // First, check account for any active orders
        const accountResp = await fetch('/api/check_account');
        const accountData = await accountResp.json();
        
        if (accountData.error) {
            throw new Error(accountData.error);
        }

        // Get the crypto name from the row
        const container = document.querySelector(`[data-row-id="${rowId}"]`);
        const cryptoName = container.querySelector('.crypto-title').textContent.trim();

        // Look for any open orders for this crypto
        const activeOrder = accountData.orders.find(order => order.name === cryptoName);
        
        // Also get the order status from our backend
        const statusResp = await fetch(`/order/status/${rowId}`);
        const currentState = await statusResp.json();

        if (!currentState || currentState.error) {
            throw new Error(currentState?.error || "Failed to get order status");
        }

        // If we have an active sell order in the account data
        if (activeOrder && activeOrder.order.toLowerCase().includes('sell')) {
            if (statusDiv) {
                const priceDiff = currentState.current_price_diff || 0;
                const sign = priceDiff >= 0 ? "+" : "";
                statusDiv.textContent = `Sell Order Open [${sign}${priceDiff.toFixed(2)}%]`;
                setButtonState(rowId, 'sell', 'enabled');
                setButtonState(rowId, 'buy', 'disabled');
                statusDiv.style.color = priceDiff >= 0 ? "green" : "red";
                statusDiv.style.display = 'inline';
            }
            
            // Start price tracking
            startPriceTracking(rowId, container);
            return true;
        }

        // Handle other states based on our backend status
        switch(currentState.status) {
            case "buy_filled":
                statusDiv.textContent = "Buy Order Filled - Placing Stop Loss...";
                statusDiv.style.color = "yellow";
                return false;

            case "sell_open":
                const priceDiff = currentState.current_price_diff || 0;
                const sign = priceDiff >= 0 ? "+" : "";
                statusDiv.textContent = `Sell Order Open [${sign}${priceDiff.toFixed(2)}%]`;
                setButtonState(rowId, 'sell', 'enabled');
                setButtonState(rowId, 'buy', 'disabled');
                statusDiv.style.color = priceDiff >= 0 ? "green" : "red";
                const dotColor = percentDiff >= 0 ? "green" : "red";
                buyOrderStatus.style.color = dotColor;
                updateDot(true, dotColor);
                return true;

            case "completed":
                const completedSign = currentState.percent_gain >= 0 ? "+" : "";
                statusDiv.textContent = `Trade Completed [${completedSign}${currentState.percent_gain.toFixed(2)}%]`;
                setButtonState(rowId, 'sell', 'disabled');
                setButtonState(rowId, 'buy', 'enabled');
                statusDiv.style.color = currentState.percent_gain >= 0 ? "green" : "red";
                cleanupPollingDot(rowId);
                const cancelButton = container.querySelector('.cancel-button');
                if (cancelBtn) {
                    cancelBtn.textContent = "Reset";
                    cancelBtn.style.backgroundColor = "#ff8c00";
                    cancelBtn.classList.add("reset-button");
                }
                return true;

            case "error":
                throw new Error(currentState.error || "Order failed");

            default:
                return false;
        }
    } catch (error) {
        console.error("Status check error:", error);
        throw error;
    }
}

async function marketBuy(button) {
    const container = button.closest("tr") || button.closest(".crypto-item");
    if (!container) return;

    const rowId = container.getAttribute("data-row-id");
    if (!rowId) {
        console.error("Missing row_id");
        return;
    }

    const statusDiv = container.querySelector(".buyOrderStatus");
    const defaultText = container.querySelector('.status-text');
    const cancelBtn = container.querySelector('.cancel-button');

    // Store original button state
    const originalText = button.textContent;
    const originalStyle = button.style.backgroundColor;

    // Set transitional state
    container.setAttribute('data-transitioning', 'true');
    button.disabled = true;
    button.textContent = "BUYING...";
    button.style.backgroundColor = "grey";

    if (statusDiv) {
        statusDiv.textContent = "Executing Market Buy...";
        statusDiv.style.color = "yellow";
        statusDiv.style.display = 'inline';
    }
    if (defaultText) defaultText.style.display = 'none';

    try {
        // Get current state
        const stateResp = await fetch(`/order/status/${rowId}`);
        const state = await stateResp.json();

        // If there's an active sell order, just flash red and return
        if (state && state.status === "sell_open") {
            button.style.backgroundColor = "red";
            setTimeout(() => {
                button.style.backgroundColor = "#0077cc";
                button.disabled = false;
            }, 300);
            return;
        }

        // Get necessary information from the container
        const amountInput = container.querySelector('input[type="number"]');
        const sellInput = container.querySelector('.stop-loss-input');
        const takeProfitInput = container.querySelector('.take-profit-input');
        const titleEl = container.querySelector('.crypto-title');
        
        if (!amountInput || !sellInput || !titleEl) {
            throw new Error("Required inputs not found");
        }

        const pair = titleEl.textContent.trim().toUpperCase() + "USD";
        const usdAmount = parseFloat(amountInput.value);
        const sellPercent = parseFloat(sellInput.value);
        const takeProfit = takeProfitInput ? parseFloat(takeProfitInput.value) : null;

        // If there's an active buy order, cancel it first
        if (state && state.status === "buy_open" && state.buy_order_id) {
            const cancelResp = await fetch("/order/cancel", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ row_id: rowId })
            });

            if (!cancelResp.ok) {
                throw new Error("Failed to cancel buy order");
            }

            // Wait for cancellation confirmation
            let cancelled = false;
            for (let i = 0; i < 5; i++) {
                await new Promise(resolve => setTimeout(resolve, 1000));
                const checkResp = await fetch(`/order/status/${rowId}`);
                const checkState = await checkResp.json();
                if (checkState.status === "cancelled") {
                    cancelled = true;
                    break;
                }
            }

            if (!cancelled) {
                throw new Error("Cancellation not confirmed");
            }
        }

        // Place market buy order
        const orderResp = await fetch("/order/market_buy", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                row_id: rowId,
                pair: pair,
                usd_amount: usdAmount,
                sell_percent: sellPercent,
                take_profit: takeProfit
            })
        });

        if (!orderResp.ok) {
            const error = await orderResp.json();
            throw new Error(error.error || "Failed to place market buy");
        }

        // Update status to show market buy is completed
        if (statusDiv) {
            statusDiv.textContent = "Market Buy Completed";
            statusDiv.style.color = "green";
            
            // Optional: Briefly show the completed status before changing to "Sending Sell Order..."
            setTimeout(() => {
                statusDiv.textContent = "Sending Sell Order...";
                statusDiv.style.color = "yellow";
            }, 1500);  // Show for 1.5 seconds
        }

        // Start status polling
        startOrderStatusPolling(rowId, container);

        // Reset button to original state after successful order
        button.textContent = originalText;
        button.style.backgroundColor = originalStyle;
        button.disabled = false;

    } catch (error) {
        console.error("Market buy failed:", error);
        if (statusDiv) {
            statusDiv.textContent = `Error: ${error.message}`;
            statusDiv.style.color = "red";
        }
        button.disabled = false;
        button.textContent = "BUY";
        button.style.backgroundColor = "#0077cc";
    } finally {
        container.removeAttribute('data-transitioning');
    }
}

// Function to continuously track price changes for sell orders
function startPriceTracking(rowId, container) {
    if (!window.priceTrackers) window.priceTrackers = {};
    
    // Clear existing tracker
    if (window.priceTrackers[rowId]) {
        clearInterval(window.priceTrackers[rowId]);
    }
    
    const statusDiv = container.querySelector(".buyOrderStatus");
    window.priceTrackers[rowId] = setInterval(async () => {
        try {
            const response = await fetch(`/order/status/${rowId}`);
            const state = await response.json();
            
            if (!state || !state.sell_order_id) {
                clearInterval(window.priceTrackers[rowId]);
                delete window.priceTrackers[rowId];
                return;
            }
            
            if (statusDiv && state.current_price_diff !== undefined) {
                const sign = state.current_price_diff >= 0 ? "+" : "";
                statusDiv.textContent = `Sell Order Open [${sign}${state.current_price_diff.toFixed(2)}%]`;
                setButtonState(rowId, 'sell', 'enabled');
                setButtonState(rowId, 'buy', 'disabled');
                statusDiv.style.color = state.current_price_diff >= 0 ? "green" : "red";
                }
        } catch (error) {
            console.error("Error tracking price:", error);
        }
    }, 2000);
}

async function cancelStopLossWithRetry(orderId, rowId, maxRetries = 5, delayMs = 2000) {
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            console.log(`Attempting to cancel stop-loss order ${orderId} (attempt ${attempt}/${maxRetries})`);
            
            // Try to cancel the order
            const cancelResult = await fetch("/order/cancel", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ 
                    row_id: rowId,
                    order_id: orderId 
                })
            });

            if (!cancelResult.ok) {
                const error = await cancelResult.json();
                if (error.error?.includes('Rate limit exceeded')) {
                    console.log(`Rate limit hit, waiting ${delayMs}ms before retry...`);
                    await new Promise(resolve => setTimeout(resolve, delayMs));
                    continue;
                }
                throw new Error(error.error || 'Failed to cancel order');
            }

            // Verify cancellation
            let cancelled = false;
            for (let checkAttempt = 1; checkAttempt <= 3; checkAttempt++) {
                try {
                    const checkResult = await fetch(`/api/kraken/order/${orderId}`);
                    if (!checkResult.ok) continue;
                    
                    const orderStatus = await checkResult.json();
                    if (orderStatus.status === "canceled" || 
                        orderStatus.status === "cancelled" || 
                        orderStatus.reason === "order_not_found") {
                        cancelled = true;
                        break;
                    }
                } catch (checkError) {
                    console.error(`Error checking cancellation (attempt ${checkAttempt}):`, checkError);
                }
                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            if (cancelled) {
                console.log(`Successfully cancelled stop-loss order ${orderId}`);
                return true;
            }
            
            // If we got here but order isn't confirmed cancelled, wait and retry
            await new Promise(resolve => setTimeout(resolve, delayMs));
            
        } catch (error) {
            console.error(`Error cancelling stop-loss (attempt ${attempt}):`, error);
            if (attempt === maxRetries) throw error;
            await new Promise(resolve => setTimeout(resolve, delayMs));
        }
    }
    
    throw new Error(`Failed to cancel stop-loss after ${maxRetries} attempts`);
}

// Add these helper functions:

// 1. Function to check and clear any lingering orders for this crypto
async function checkAndClearCryptoOrders(container) {
    try {
        const cryptoName = container.querySelector('.crypto-title')?.textContent.trim();
        if (!cryptoName) return false;
        
        // Get all active orders
        const response = await fetch('/api/check_account');
        const data = await response.json();
        
        if (data.error || !data.orders) return false;
        
        // Find any orders for this crypto
        const cryptoOrders = data.orders.filter(order => order.name === cryptoName);
        if (cryptoOrders.length === 0) return true; // No orders to clear
        
        console.log(`Found ${cryptoOrders.length} active orders for ${cryptoName}`);
        
        // Cancel each order
        for (const order of cryptoOrders) {
            console.log(`Cancelling leftover order: ${order.id}`);
            await fetch(`/api/cancel_order/${order.id}`, {
                method: 'POST'
            });
            
            // Small delay between cancellations
            await new Promise(r => setTimeout(r, 500));
        }
        
        return true;
    } catch (error) {
        console.error("Error in checkAndClearCryptoOrders:", error);
        return false;
    }
}

// 2. Function to run a full UI reset when needed (especially on insufficient funds errors)
function fullUIReset(container) {
    const mainButton = container.querySelector('button:not(.buy-btn):not(.sell-btn)');
    if (mainButton) {
        resetTradeUI(mainButton, container);
    }
}

async function marketSell(button) {
    // Same container finding logic as before...
    let container = button.closest('tr');
    if (!container) {
        container = button.closest('.crypto-item');
    }
    
    if (!container) {
        console.error('Could not find container for market sell');
        let potentialContainers = [
            button.parentElement,
            button.parentElement.parentElement,
            button.closest('div[data-row-id]')
        ];
        
        for (let potential of potentialContainers) {
            if (potential) {
                container = potential;
                break;
            }
        }
        
        if (!container) {
            console.error('Unable to process sell order: container not found');
            return;
        }
    }

    const rowId = container.getAttribute('data-row-id') || container.id;
    const statusDiv = container.querySelector('.buyOrderStatus');
    const defaultText = container.querySelector('.status-text');
    const marketSellBtn = container.querySelector('.sell-btn');
    const marketBuyBtn = container.querySelector('.buy-btn');
    
    // Set transitional state flag
    container.setAttribute('data-transitioning', 'true');
            
    try {
        await checkAndClearCryptoOrders(container);
        // Get current fee rates first
        const feeRates = await getCurrentFeeRates();
        console.log(`Current fee rates - Maker: ${feeRates.maker}%, Taker: ${feeRates.taker}%`);
        
        const stateResp = await fetch(`/order/status/${rowId}`);
        const state = await stateResp.json();
    
        if (!state || !state.pair) {
            throw new Error("Could not retrieve order state");
        }
        
        // Check account balance
        const balanceResp = await fetch('/api/check_account');
        if (!balanceResp.ok) {
            throw new Error("Failed to check account balances");
        }
        
        const accountData = await balanceResp.json();
        const cryptoName = state.pair.replace('USD', '');

        // Find the crypto balance
        const cryptoBalance = accountData.balances.find(b => b.name === cryptoName);
        if (!cryptoBalance || cryptoBalance.quantity <= 0) {
            alert(`Insufficient balance for ${cryptoName}`);
            throw new Error(`No balance available for ${cryptoName}`);
        }

        if (!state || !state.filled_volume) {
            button.style.backgroundColor = "red";
            setTimeout(() => {
                button.style.backgroundColor = "#f97316";
                button.disabled = false;
            }, 300);
            return;
        }

        // Get current price for fee calculation
        const currentPrice = state.current_price || await getLatestPrice(state.pair);
        
        // Calculate percentage with fees
        let capturedPriceDiff = null;
        if (state.buy_fill_price && currentPrice) {
            // Use taker fee for market sell calculations
            const takerFee = feeRates.taker;
            
            // First calculate raw percentage difference
            const rawPriceDiff = ((currentPrice - state.buy_fill_price) / state.buy_fill_price) * 100;
            
            // IMPROVED FEE CALCULATION:
            // 1. Calculate effective buy price including fees
            const effectiveBuyPrice = state.buy_fill_price * (1 + takerFee/100);
            
            // 2. Calculate effective sell price after fees
            const effectiveSellPrice = currentPrice * (1 - takerFee/100);
            
            // 3. Calculate final percentage with fees included on both sides
            capturedPriceDiff = ((effectiveSellPrice - effectiveBuyPrice) / effectiveBuyPrice) * 100;
            
            console.log(`Market Sell: Raw price diff: ${rawPriceDiff.toFixed(2)}%, With fees: ${capturedPriceDiff.toFixed(2)}%`);
            console.log(`Effective Buy Price: ${effectiveBuyPrice}, Effective Sell Price: ${effectiveSellPrice}`);
        } else if (statusDiv && statusDiv.textContent) {
            // Fallback to extracting from status text
            const priceDiffMatch = statusDiv.textContent.match(/\[([-+]?\d+\.\d+)%\]/);
            if (priceDiffMatch && priceDiffMatch[1]) {
                capturedPriceDiff = parseFloat(priceDiffMatch[1]);
                // Note: This percentage likely already includes fee impact, so we don't adjust again
                console.log(`Captured price difference from status: ${capturedPriceDiff}%`);
            }
        }
        
        // Also get the percentage from the state if available as backup
        const statePriceDiff = state.current_price_diff !== undefined ? state.current_price_diff : null;
        
        // Use captured percentage if available, otherwise fall back to state percentage
        const finalPercentage = capturedPriceDiff !== null ? capturedPriceDiff : statePriceDiff;

        // Store original button state
        const originalButtonText = button.textContent;
        const originalButtonColor = button.style.backgroundColor;

        // Update button to show selling state
        button.disabled = true;
        button.textContent = "SELLING...";
        button.style.backgroundColor = "grey";

        // Get the sell type from dropdown
        const sellType = document.getElementById('sellTypeDropdown').value;
        console.log(`Using sell type: ${sellType}`);

        // Add a delay function to help with rate limiting
        const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

        // If there's an existing sell order that needs to be cancelled first
        if (state && state.sell_order_id) {
            try {
                // Add a random delay before cancellation to avoid rate limit clustering
                await delay(Math.random() * 500 + 500); // 500-1000ms delay
                
                console.log(`Attempting to cancel existing stop-loss order: ${state.sell_order_id}`);
                
                // Try cancellation with multiple retries
                let cancelSuccess = false;
                for (let attempt = 1; attempt <= 3; attempt++) {
                    try {
                        const cancelResp = await fetch("/order/cancel", {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({ row_id: rowId })
                        });
                        
                        if (cancelResp.ok) {
                            console.log("Successfully cancelled existing order");
                            cancelSuccess = true;
                            
                            // Important: Wait after cancellation before placing new order
                            await delay(1500); // 1.5 second wait after successful cancel
                            break;
                        } else {
                            console.warn(`Cancel attempt ${attempt} failed`);
                            await delay(1000 * attempt); // Increasing delay between retries
                        }
                    } catch (error) {
                        console.warn(`Cancel attempt ${attempt} error: ${error.message}`);
                        await delay(1000 * attempt);
                    }
                }
                
                if (!cancelSuccess) {
                    console.log("All cancel attempts failed, will try market sell anyway");
                    await delay(2000); // Wait a bit longer before proceeding
                }
            } catch (cancelError) {
                console.error('Error in cancellation process:', cancelError);
                // Continue with market sell even if cancellation fails
                await delay(2000);
            }
        }

        // Cancel existing stop-loss first
        if (state.sell_order_id) {
            try {
                const orderState = await cancelOrder(container.querySelector('button.cancel-button'));
                
                // For limit sell, extract current price difference
                if (sellType === 'limit') {
                    // Use our captured percentage for the limit sell
                    if (finalPercentage !== null) {
                        try {
                            // For limit sell, we need to adjust the target percentage UP by the fee amount
                            // to ensure we actually get our desired percentage after fees
                            const makerFee = feeRates.maker;
                            const adjustedTargetPercent = finalPercentage + makerFee;
                            
                            console.log(`Placing limit sell at adjusted percentage: ${finalPercentage}% + ${makerFee}% fee = ${adjustedTargetPercent}%`);
                            
                            const response = await fetch("/order/limit_sell", {
                                method: "POST",
                                headers: { "Content-Type": "application/json" },
                                body: JSON.stringify({
                                    row_id: rowId,
                                    target_percent: adjustedTargetPercent, // Use fee-adjusted percentage
                                    original_target: finalPercentage // Store original for reference
                                })
                            });
                            
                            if (!response.ok) {
                                // Instead of showing an alert and stopping, log the error and continue to market sell
                                console.error('Error placing limit sell:', await response.json());
                                console.log('Falling back to market sell silently');
                                // Continue execution to market sell fallback below
                            } else {
                                return; // Exit early since limit sell succeeded
                            }
                        } catch (limitError) {
                            console.error('Error placing limit sell:', limitError);
                            console.log('Falling back to market sell silently');
                            // Continue execution to market sell fallback below
                        }
                    }
                }
            } catch (cancelError) {
                console.error('Error cancelling order:', cancelError);
            }
        }

        let volume = state.filled_volume;
        if (!volume) {
            const amountField = container.querySelector('input[type="number"]');
            if (amountField) {
                volume = parseFloat(amountField.value);
            }
        }

        if (volume > cryptoBalance.quantity) {
            // Adjust volume to available balance
            volume = cryptoBalance.quantity;
            console.log(`Adjusted sell volume to available balance: ${volume}`);
        }

        button.disabled = true;
        button.textContent = "Selling...";
        button.style.backgroundColor = "grey";

        if (statusDiv) {
            statusDiv.textContent = "Placing market sell...";
            statusDiv.style.color = "yellow";
        }
        if (defaultText) defaultText.style.display = 'none';

        // If we have a captured percentage, include it in the market sell request
        const requestBody = {
            row_id: rowId,
            volume: volume
        };
        
        if (finalPercentage !== null) {
            requestBody.captured_percentage = finalPercentage;
        }
        
        // Add fee information to the request
        requestBody.fee_rates = {
            maker: feeRates.maker,
            taker: feeRates.taker
        };

        const resp = await fetch("/order/market_sell", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(requestBody)
        });

        if (!resp.ok) {
            const error = await resp.json();
            throw new Error(error.error || "Failed to place market sell");
        }
        
        const data = await resp.json();
        
        if (statusDiv) {
            statusDiv.textContent = "Executing Market Sell...";
            statusDiv.style.color = "yellow";
        }
        if (defaultText) defaultText.style.display = 'none';

        button.style.display = "inline-block";
        button.textContent = "SELL";
        button.style.backgroundColor = "#f97316";
        button.disabled = true;

        // Monitor completion with timeout
        const maxMonitorAttempts = 30;
        let monitorAttempts = 0;
        const checkCompletion = setInterval(async () => {
            try {
                monitorAttempts++;
                const statusResp = await fetch(`/order/status/${rowId}`);
                const currentState = await statusResp.json();

                if (currentState.status === "completed") {
                    clearInterval(checkCompletion);
                    cleanupPollingDot(rowId);
                    
                    // NEW CODE: Fetch the accurate percentage from Kraken
                    try {
                        const tradeDataResp = await fetch('/api/get_recent_trade', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                pair: state.pair,
                                volume: volume
                            })
                        });
                        
                        if (tradeDataResp.ok) {
                            const tradeData = await tradeDataResp.json();
                            
                            // Use the accurate net percentage from Kraken
                            const displayPercentage = tradeData.netPercentage;
                            console.log("Got accurate percentage from Kraken (including fees):", displayPercentage);
                            console.log("Trade details:", tradeData.details);
                            
                            // Update the UI with this accurate percentage
                            if (statusDiv) {
                                const sign = displayPercentage >= 0 ? "+" : "";
                                statusDiv.textContent = `Trade Completed [${sign}${displayPercentage.toFixed(2)}%]`;
                                setButtonState(rowId, 'sell', 'disabled');
                                setButtonState(rowId, 'buy', 'enabled');
                                statusDiv.style.color = displayPercentage >= 0 ? "green" : "red";
                                statusDiv.style.display = 'inline';
                            }
                            
                            // Also update the state
                            if (typeof order_states !== 'undefined' && rowId in order_states) {
                                order_states[rowId].percent_gain = displayPercentage;
                            }
                            
                            // Update cancel button to reset
                            const cancelButton = container.querySelector('.cancel-button');
                            if (cancelButton) {
                                cancelButton.textContent = "Reset";
                                cancelButton.style.backgroundColor = "#ff8c00";
                                cancelButton.classList.add("reset-button");
                            }
                            
                            // Clean up all intervals
                            if (orderPollingIntervals[rowId]) {
                                clearInterval(orderPollingIntervals[rowId]);
                                delete orderPollingIntervals[rowId];
                            }
                            if (window.pctTrackers && window.pctTrackers[rowId]) {
                                clearInterval(window.pctTrackers[rowId]);
                                delete window.pctTrackers[rowId];
                            }
                            
                            // Re-enable auto-refresh
                            updateAutoRefreshVisibility(false);
                            container.removeAttribute('data-transitioning');
                            return;
                        }
                    } catch (accuracyError) {
                        console.error("Error getting accurate percentage:", accuracyError);
                    }
                    
                    // Fallback to manually calculating with fees if API call fails
                    if (currentState.buy_fill_price && currentState.final_price) {
                        try {
                            // Get buy price, sell price, and fee rates
                            const buyPrice = currentState.buy_fill_price;
                            const sellPrice = currentState.final_price;
                            const takerFee = feeRates.taker / 100; // Convert to decimal
                            
                            // Calculate fees 
                            const effectiveBuyPrice = buyPrice * (1 + takerFee);
                            const effectiveSellPrice = sellPrice * (1 - takerFee);
                            
                            // Calculate net percentage gain/loss with fees
                            const netPercentage = ((effectiveSellPrice - effectiveBuyPrice) / effectiveBuyPrice) * 100;
                            
                            console.log(`Manual calculation with fees: Buy ${buyPrice}, Sell ${sellPrice}`);
                            console.log(`Effective Buy ${effectiveBuyPrice}, Effective Sell ${effectiveSellPrice}`);
                            console.log(`Net percentage with fees: ${netPercentage.toFixed(2)}%`);
                            
                            // Update display with properly calculated net percentage
                            if (statusDiv) {
                                const sign = netPercentage >= 0 ? "+" : "";
                                statusDiv.textContent = `Trade Completed [${sign}${netPercentage.toFixed(2)}%]`;
                                statusDiv.style.color = netPercentage >= 0 ? "green" : "red";
                    }
                            
                            // Update state with properly calculated net percentage
                            if (typeof order_states !== 'undefined' && rowId in order_states) {
                                order_states[rowId].percent_gain = netPercentage;
                            }
                        } catch (calcError) {
                            console.error("Error in manual fee calculation:", calcError);
                        }
                    } else {
                        // Second fallback: use the percentage provided by backend if available
                        const displayPercentage = currentState.percent_gain || finalPercentage;
                    if (displayPercentage !== null) {
                        const sign = displayPercentage >= 0 ? "+" : "";
                        if (statusDiv) {
                            statusDiv.textContent = `Trade Completed [${sign}${displayPercentage.toFixed(2)}%]`;
                            statusDiv.style.color = displayPercentage >= 0 ? "green" : "red";
                            }
                        }
                    }

                    // Update cancel button to reset
                    const cancelButton = container.querySelector('.cancel-button');
                    if (cancelButton) {
                        cancelButton.textContent = "Reset";
                        cancelButton.style.backgroundColor = "#ff8c00";
                        cancelButton.classList.add("reset-button");
                    }

                    // Clean up all intervals
                    if (orderPollingIntervals[rowId]) {
                        clearInterval(orderPollingIntervals[rowId]);
                        delete orderPollingIntervals[rowId];
                    }
                    if (window.pctTrackers && window.pctTrackers[rowId]) {
                        clearInterval(window.pctTrackers[rowId]);
                        delete window.pctTrackers[rowId];
                    }

                    // Re-enable auto-refresh
                    updateAutoRefreshVisibility(false);
                    container.removeAttribute('data-transitioning');
                    return;
                }
                
                if (monitorAttempts >= maxMonitorAttempts) {
                    clearInterval(checkCompletion);
                    if (statusDiv) {
                        statusDiv.textContent = "Timeout waiting for completion";
                        statusDiv.style.color = "red";
                    }
                    // Reset button state
                    button.disabled = false;
                    button.textContent = originalButtonText;
                    button.style.backgroundColor = originalButtonColor;
                    container.removeAttribute('data-transitioning');
                }
            } catch (error) {
                console.error("Error checking completion:", error);
                clearInterval(checkCompletion);
                if (statusDiv) {
                    statusDiv.textContent = `Error: ${error.message}`;
                    statusDiv.style.color = "red";
                }
                // Reset button state
                button.disabled = false;
                button.textContent = originalButtonText;
                button.style.backgroundColor = originalButtonColor;
                container.removeAttribute('data-transitioning');
            }
        }, 1000);

    } catch (error) {
        console.error("Market sell failed:", error);
        if (statusDiv) {
            statusDiv.textContent = `Error: ${error.message}`;
            statusDiv.style.color = "red";
        }

        if (error.message.includes("Insufficient") || error.message.includes("insufficient")) {
            alert("Error: Insufficient balance. This may occur if the trade is already completed or if there are pending orders. The interface will be reset.");
            fullUIReset(container);
            return;
        }
        
        button.disabled = false;
        button.textContent = "SELL";
        button.style.backgroundColor = "#f97316";
        container.removeAttribute('data-transitioning');
    }
}

function resetTradeUI(button, container) {
    // Get row ID for state management
    const rowId = container.getAttribute('data-row-id');
    console.log(`Executing complete UI reset for row: ${rowId}`);
    
    // Clean up any existing intervals and animations
    cleanupPollingDot(rowId);
    
    // Get all relevant buttons and status elements
    const marketBuyBtn = container.querySelector('.buy-btn');
    const marketSellBtn = container.querySelector('.sell-btn');
    const statusDiv = container.querySelector('.buyOrderStatus');
    const defaultText = container.querySelector('.status-text');
    const pollingDot = container.querySelector('.polling-dot');
    
    // PHASE 1: Reset backend state through API call
    // This ensures server-side state is consistent
    fetch('/order/update_take_profit', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
            row_id: rowId,
            reset_state: true  // Add this flag to signal complete reset
        })
    }).catch(err => {
        console.error("Backend state reset error:", err);
        // Continue with UI reset even if backend fails
    });
    
    // PHASE 2: Reset main Trade/Cancel/Reset button
    button.disabled = false;
    button.textContent = "Trade";
    button.style.backgroundColor = "green";
    button.classList.remove("cancel-button", "reset-button");
    button.onclick = () => placeTrailingStopBuy(button);
    button.onmouseover = () => button.style.backgroundColor = "darkgreen";
    button.onmouseout = () => button.style.backgroundColor = "green";

    // PHASE 3: Reset Buy button (always enabled after reset)
    if (marketBuyBtn) {
        marketBuyBtn.disabled = false;
        marketBuyBtn.style.backgroundColor = "#0077cc";
        marketBuyBtn.style.cursor = "pointer";
        marketBuyBtn.onmouseover = () => marketBuyBtn.style.backgroundColor = "#005599";
        marketBuyBtn.onmouseout = () => marketBuyBtn.style.backgroundColor = "#0077cc";
    }

    // PHASE 4: Reset Sell button (always disabled after reset)
    if (marketSellBtn) {
        marketSellBtn.disabled = true;
        marketSellBtn.style.backgroundColor = "#bebebe";
        marketSellBtn.style.cursor = "not-allowed";
        marketSellBtn.onmouseover = null;
        marketSellBtn.onmouseout = null;
    }

    // PHASE 5: Reset polling dot by recreating it completely
    if (pollingDot) {
        const parentElement = pollingDot.parentElement;
        // Completely remove the old polling dot
        pollingDot.remove();
        
        // Create a fresh new polling dot
        const newPollingDot = document.createElement('div');
        newPollingDot.className = 'polling-dot';
        newPollingDot.style.display = 'none';
        newPollingDot.style.animation = 'none';
        
        // Insert the new dot at the beginning of the status container
        if (parentElement) {
            parentElement.insertBefore(newPollingDot, parentElement.firstChild);
            console.log("Created new polling dot");
        }
    } else {
        console.log("No polling dot found to recreate");
        // Create polling dot if it doesn't exist
        const statusContainer = container.querySelector('.status-container');
        if (statusContainer) {
            const newPollingDot = document.createElement('div');
            newPollingDot.className = 'polling-dot';
            newPollingDot.style.display = 'none';
            statusContainer.insertBefore(newPollingDot, statusContainer.firstChild);
            console.log("Created missing polling dot");
        }
    }

    // PHASE 6: Reset status text
    if (statusDiv) {
        statusDiv.textContent = "Inactive";
        statusDiv.style.color = "#666";
        statusDiv.style.display = 'none';
    }

    if (defaultText) {
        defaultText.style.display = 'inline';
        defaultText.textContent = "Inactive";
        defaultText.style.color = "#666";
    }

    // PHASE 7: Clean up all tracking intervals
    if (orderPollingIntervals[rowId]) {
        clearInterval(orderPollingIntervals[rowId]);
        delete orderPollingIntervals[rowId];
    }
    
    if (window.pctTrackers && window.pctTrackers[rowId]) {
        clearInterval(window.pctTrackers[rowId]);
        delete window.pctTrackers[rowId];
    }

    // PHASE 8: Remove from order states to ensure complete reset
    if (rowId in order_states) {
        delete order_states[rowId];
        console.log(`Deleted order state for ${rowId}`);
    }
    
    // PHASE 9: Check for balance validation - the "Insufficient funds" issue
    // This async function verifies that we have no active orders for this crypto
    checkAndClearCryptoOrders(container)
        .then(cleared => {
            console.log(`Balance check completed, orders cleared: ${cleared}`);
        })
        .catch(err => {
            console.error("Balance check error:", err);
        });
    
    // PHASE 10: Re-enable auto-refresh if it was disabled
    updateAutoRefreshVisibility(false);
    
    console.log(`Reset completed for row ${rowId}`);
    return true;
}

async function checkAndClearCryptoOrders(container) {
    try {
        const cryptoName = container.querySelector('.crypto-title')?.textContent.trim();
        if (!cryptoName) return false;
        
        // Get all active orders
        const response = await fetch('/api/check_account');
        const data = await response.json();
        
        if (data.error || !data.orders) return false;
        
        // Find any orders for this crypto
        const cryptoOrders = data.orders.filter(order => order.name === cryptoName);
        if (cryptoOrders.length === 0) return true; // No orders to clear
        
        console.log(`Found ${cryptoOrders.length} active orders for ${cryptoName}`);
        
        // Cancel each order
        for (const order of cryptoOrders) {
            console.log(`Cancelling leftover order: ${order.id}`);
            await fetch(`/api/cancel_order/${order.id}`, {
                method: 'POST'
            });
            
            // Small delay between cancellations
            await new Promise(r => setTimeout(r, 500));
        }
        
        return true;
    } catch (error) {
        console.error("Error in checkAndClearCryptoOrders:", error);
        return false;
    }
}

// New function to properly check balance before selling
async function validateSellBalance(cryptoName, volume) {
    try {
        // Get account balances
        const response = await fetch('/api/check_account');
        const data = await response.json();
        
        if (data.error) {
            throw new Error(data.error);
        }
        
        // Find balance for this crypto
        const balance = data.balances.find(b => b.name === cryptoName);
        const available = balance ? balance.quantity : 0;
        
        console.log(`Validating sell for ${cryptoName}: requested ${volume}, available ${available}`);
        
        // Check if we have enough balance
        if (!balance || available < volume) {
            throw new Error(`Insufficient balance: requested ${volume} but only have ${available} ${cryptoName}`);
        }
        
        return true;
    } catch (error) {
        console.error("Balance validation error:", error);
        throw error;
    }
}

    function resetTradeButton(button) {
        if (!button) return;
        button.textContent = "Trade";
        button.style.backgroundColor = "rgb(0, 128, 0)";  // Original green color
        button.classList.remove("cancel-button");
        button.disabled = false;
        button.onclick = () => placeTrailingStopBuy(button);
        button.onmouseover = () => button.style.backgroundColor = "rgb(0, 100, 0)";  // Darker green
        button.onmouseout = () => button.style.backgroundColor = "rgb(0, 128, 0)";   // Back to original green
        
        // Only reset the status display if it's not showing a completion percentage
        const container = button.closest('tr') || button.closest('.crypto-item');
        if (container) {
            const statusDiv = container.querySelector('.buyOrderStatus');
            const defaultText = statusDiv.parentElement.querySelector('.status-text');
            
            // Check if the status shows a percentage (completed trade)
            if (!statusDiv.textContent.includes('%') || statusDiv.textContent.includes('Order')) {
                statusDiv.style.display = 'none';
                defaultText.style.display = 'inline';
            }
        }
    }

    function handleCompletedTradeState(state, container) {
    const rowId = container.getAttribute('data-row-id');
    if (!state || !rowId) return;
    
    // Get UI elements
    const statusDiv = container.querySelector('.buyOrderStatus');
    const defaultText = container.querySelector('.status-text');
    const mainButton = container.querySelector('button:not(.buy-btn):not(.sell-btn)');
    const marketSellBtn = container.querySelector('.sell-btn');
    const marketBuyBtn = container.querySelector('.buy-btn');
    const pollingDot = container.querySelector('.polling-dot');
    
    // Hide polling dot
    if (pollingDot) pollingDot.style.display = 'none';
    
    // Display completion status with percentage
    if (statusDiv) {
        const percentGain = state.percent_gain || state.captured_percentage || 0;
        const sign = percentGain >= 0 ? "+" : "";
        statusDiv.textContent = `Trade Completed [${sign}${percentGain.toFixed(2)}%]`;
        statusDiv.style.color = percentGain >= 0 ? "green" : "red";
        statusDiv.style.display = 'inline';
    }
    
    // Hide default status text
    if (defaultText) defaultText.style.display = 'none';
    
    // Update main button to Reset
    if (mainButton) {
        mainButton.textContent = "Reset";
        mainButton.style.backgroundColor = "#ff8c00";
        mainButton.classList.add("reset-button");
        mainButton.onmouseover = () => mainButton.style.backgroundColor = "#e67e00";
        mainButton.onmouseout = () => mainButton.style.backgroundColor = "#ff8c00";
    }
    
    // Disable sell button
    if (marketSellBtn) {
        marketSellBtn.disabled = true;
        marketSellBtn.style.backgroundColor = "#bebebe";
        marketSellBtn.style.cursor = "not-allowed";
    }
    
    // Enable buy button
    if (marketBuyBtn) {
        marketBuyBtn.disabled = false;
        marketBuyBtn.style.backgroundColor = "#0077cc";
        marketBuyBtn.style.cursor = "pointer";
    }
    
    // Clear intervals
    if (orderPollingIntervals[rowId]) {
        clearInterval(orderPollingIntervals[rowId]);
        delete orderPollingIntervals[rowId];
    }
    
    if (window.pctTrackers && window.pctTrackers[rowId]) {
        clearInterval(window.pctTrackers[rowId]);
        delete window.pctTrackers[rowId];
    }
    
    // Re-enable auto-refresh
    updateAutoRefreshVisibility(false);
}

    async function retryStatusCheck(rowId, maxRetries = 3, delay = 2000) {
    const container = document.querySelector(`[data-row-id="${rowId}"]`);
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            const response = await fetch(`/order/status/${rowId}`);
            if (!response.ok) throw new Error('Status check failed');
            
            const state = await response.json();
            
            // If this is a completed trade, ensure UI reflects it
            if (state.status === "completed" && container) {
                handleCompletedTradeState(state, container);
            }
            
            return state;
        } catch (error) {
            console.log(`Status check attempt ${attempt} failed:`, error);
            if (attempt === maxRetries) throw error;
            await new Promise(resolve => setTimeout(resolve, delay));
        }
    }
    throw new Error('Max retries exceeded');
}

    async function cancelOrder(button) {
    // First check if this is a reset button
    if (button.classList.contains('reset-button')) {
        // For reset button, just reset the UI without making server call
        const container = button.closest('tr') || button.closest('.crypto-item');
        if (container) {
            resetTradeUI(button, container);
        }
        return;
    }

    const container = button.closest("tr") || button.closest(".crypto-item");
    if (!container) return;

    // Immediately update button appearance
    const originalText = button.textContent;
    const originalBackground = button.style.backgroundColor;
    button.textContent = "Canceling...";
    button.style.backgroundColor = "#666666";
    button.disabled = true;

    const rowId = container.getAttribute("data-row-id");
    const statusDiv = container.querySelector(".buyOrderStatus");
    const marketSellBtn = container.querySelector('.sell-btn');
    const marketBuyBtn = container.querySelector('.buy-btn');
    const defaultText = container.querySelector('.status-text');
    
    // Immediately clear all tracking intervals
    if (orderPollingIntervals[rowId]) {
        clearInterval(orderPollingIntervals[rowId]);
        delete orderPollingIntervals[rowId];
    }
    if (window.pctTrackers && window.pctTrackers[rowId]) {
        clearInterval(window.pctTrackers[rowId]);
        delete window.pctTrackers[rowId];
    }

    // Set transitional state flag to prevent status updates
    container.setAttribute('data-transitioning', 'true');
    
    try {
        // Get current state to identify the order to cancel
        const stateResp = await fetch(`/order/status/${rowId}`);
        const state = await stateResp.json();
        
        // If order not found or trade is completed, just reset UI without showing error
        if (!state || state.status === "completed" || state.reason === "order_not_found") {
            resetTradeUI(button, container);
            return;
        }

        // Store important state values before cancellation
        const preservedState = {
            pair: state.pair,
            buy_fill_price: state.buy_fill_price,
            filled_volume: state.filled_volume,
            current_price_diff: state.current_price_diff,
            history: state.history
        };

        // Send cancel request to server
        const resp = await fetch("/order/cancel", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ 
                row_id: rowId,
                preserve_state: true,  // Tell server to preserve state
                state: preservedState  // Send state to preserve
            })
        });

        // Handle server response
            const data = await resp.json();
        if (!resp.ok && !data.error?.includes("Unknown order")) {
            throw new Error(data.error || "Failed to cancel order");
        }

        // Only reset UI if this isn't part of a market sell operation
        const isMarketSell = button.classList.contains('market-sell-button');
        if (!isMarketSell) {
            resetTradeUI(button, container);
        }

        // Remove transitional state flag
        container.removeAttribute('data-transitioning');
        return preservedState;

    } catch (err) {
        console.error("Cancel failed:", err);
        // Only show alert for errors other than "Unknown order"
        if (!err.message?.includes("Unknown order")) {
        alert('Error canceling order: ' + err.message);
        }
        
        // Reset button state even on error
        if (!button.classList.contains('market-sell-button')) {
            button.textContent = originalText;
            button.style.backgroundColor = originalBackground;
            button.disabled = false;
            resetTradeUI(button, container);
            }

        // Remove transitional state flag even on error
        container.removeAttribute('data-transitioning');
}
}

async function initializeMinimumAmounts() {
    window.initializationState.isInitializing = true;
    const rows = document.querySelectorAll('#cryptoTableBody tr');
    
    // Store minimum amounts in global object
    window.minimumAmounts = {};
    
    for (const row of rows) {
        const titleEl = row.querySelector('.crypto-title');
        if (!titleEl) continue;
        
        const cryptoName = titleEl.textContent.trim().toUpperCase() + "USD";
        const amountInput = row.querySelector('input[type="number"]');
        const amountLabel = amountInput?.previousElementSibling;
        
        if (!amountInput || !amountLabel) continue;
        
        try {
            const resp = await fetch(`/api/eval_roc?pair=${cryptoName}`);
            if (!resp.ok) continue;
            
            const data = await resp.json();
            if (data.min_usd) {
                // Store minimum amount
                window.minimumAmounts[cryptoName] = data.min_usd;
                
                // Set minimum amount
                amountInput.value = data.min_usd;
                amountInput.min = data.min_usd;
                
                // Style the label
                amountLabel.innerHTML = '<span style="color: red; font-weight: bold; background: black; padding: 2px 4px;">MINIMUM</span>';
                
                // Add change event listener
                amountInput.addEventListener('change', function() {
                    if (parseFloat(this.value) < data.min_usd) {
                        this.value = data.min_usd;
                        alert(`This cryptocurrency requires a minimum order of $${data.min_usd}`);
                    }
                });
            }
        } catch (err) {
            console.error(`Error checking minimum for ${cryptoName}:`, err);
        }
    }
    
    window.initializationState.minimumAmountsSet = true;
    window.initializationState.isInitializing = false;
    
    // Now apply saved amount selection if it exists
    const savedAmount = localStorage.getItem("amountSelection");
    if (savedAmount) {
        await applyAmountSelection(savedAmount);
    }
}


async function refreshAllLimits() {
    console.log("Starting refreshAllLimits with enhanced error handling");
    
    try {
        const stopLossMode = document.getElementById('stopLossSelect')?.value || 'recommended';
        const takeProfitMode = document.getElementById('takeProfitSelect')?.value || 'recommended';

    // For top picks
        console.log("Processing top picks containers...");
    const topPickContainers = document.querySelectorAll('.crypto-container .crypto-item');
    for (const container of topPickContainers) {
            try {
        if (stopLossMode === 'recommended') {
            await evalRocForContainer(container);
                }
            } catch (error) {
                console.error("Error processing top pick container:", error);
                // Continue with next container
        }
    }

    // For table rows
        console.log("Processing table rows...");
    const tableRows = document.querySelectorAll('#cryptoTableBody tr');
    for (const row of tableRows) {
            try {
                // Check if this row has a valid crypto title before processing
                const title = row.querySelector('.crypto-title');
                if (!title || title.textContent.trim() === 'USD') {
                    console.log("Skipping row with invalid or USD-only title");
                    continue;
                }
                
        if (stopLossMode === 'recommended') {
            await evalRocForContainer(row);
                }
            } catch (error) {
                console.error("Error processing table row:", error);
                // Continue with next row
        }
    }

    // Only refresh take profits if in recommended mode
    if (takeProfitMode === 'recommended') {
            console.log("Refreshing recommended take profits...");
            try {
        refreshRecommendedTakeProfits();
            } catch (error) {
                console.error("Error refreshing take profits:", error);
            }
    }

    // Add call to refresh order statuses
        try {
            console.log("Refreshing order statuses...");
    await refreshOrderStatuses();
        } catch (error) {
            console.error("Error refreshing order statuses:", error);
        }

    // Refresh transaction history if the results panel is open
    const resultsContent = document.querySelector('.results-content');
        if (resultsContent?.classList.contains('open')) {
            try {
                console.log("Refreshing transaction history...");
        await refreshTransactionHistory();
            } catch (error) {
                console.error("Error refreshing transaction history:", error);
            }
        }
        
        console.log("refreshAllLimits completed successfully");
    } catch (error) {
        console.error("Uncaught error in refreshAllLimits:", error);
    }
}


async function refreshOrderStatuses() {
  try {
      // Get all active orders from Kraken
      const response = await fetch('/api/active_orders');
      
      // Check if response is OK before proceeding
      if (!response.ok) {
          const errorText = await response.text();
          console.warn(`Active orders API returned ${response.status}: ${errorText}`);
          
          // If it's a 500 error, we'll fall back to button initialization
          // but we won't throw an error to avoid breaking the whole refresh process
          if (response.status === 500) {
              console.log("Server error when fetching active orders, falling back to button initialization");
              await initializeButtonStates();
              return;
          }
          
          throw new Error(`Failed to fetch active orders: ${response.status} ${errorText}`);
      }
      
      const data = await response.json();
      
      if (!data.orders || !data.orders.length) {
          console.log("No active orders found");
          await initializeButtonStates();
          return;
      }
      
      console.log(`Found ${data.orders.length} active orders`);
      
      const tableBody = document.getElementById('cryptoTableBody');
      
      for (const order of data.orders) {
          const basePair = order.pair.replace('USD', '');
          let row = Array.from(tableBody.rows).find(row => 
              row.querySelector('.crypto-title')?.textContent.trim() === basePair
          );
          
          if (row) {
              const rowId = row.getAttribute('data-row-id');
              if (!rowId) continue;

              // Initialize state if it doesn't exist
              if (!order_states[rowId]) {
                  order_states[rowId] = {
                      pair: order.pair,
                      status: order.type === 'buy' ? 'buy_open' : 'sell_open',
                      history: []
                  };
              }

              // Update UI based on order type
              const button = row.querySelector('button');
              const statusDiv = row.querySelector('.buyOrderStatus');
              const defaultText = row.querySelector('.status-text');

              if (defaultText) defaultText.style.display = 'none';
              if (statusDiv) {
                  statusDiv.style.display = 'inline';
                  const sign = order.price_diff >= 0 ? '+' : '';
                  
                  if (order.type === 'buy') {
                      statusDiv.textContent = `Buy Order Open [${sign}${order.price_diff.toFixed(2)}%]`;
                      statusDiv.style.color = 'yellow';
                  } else {
                      statusDiv.textContent = `Sell Order Open [${sign}${order.price_diff.toFixed(2)}%]`;
                      statusDiv.style.color = order.price_diff >= 0 ? 'green' : 'red';
                  }
              }

              // Update button state
              if (button) {
                  button.textContent = 'Cancel';
                  button.classList.add('cancel-button');
                  button.onclick = () => cancelOrder(button);
              }

              // Start status polling if not already active
              if (!orderPollingIntervals[rowId]) {
              startOrderStatusPolling(rowId, row);
          }
          } else {
              console.log(`Could not find row for ${basePair} in the table`);
          }
      }
  } catch (error) {
      console.error('Error refreshing order statuses:', error);
      // Try to fallback to button initialization but don't throw further
      // This prevents the error from breaking the entire refreshAllLimits process
      try {
          await initializeButtonStates();
      } catch (fallbackError) {
          console.error('Error in fallback initialization:', fallbackError);
      }
  }
}

async function initializeFeeAdjustedValues() {
  console.log('Starting fee-adjusted initialization...');
  
  // Get current fee rates once for all calculations
  const feeRates = await getCurrentFeeRates();
  console.log(`Current fee rates - Maker: ${feeRates.maker}%, Taker: ${feeRates.taker}%`);
  
  // Process all rows in the table
  const rows = document.querySelectorAll('#cryptoTableBody tr');
  console.log(`Processing ${rows.length} rows for fee-adjusted values`);
  
  const stopLossMode = document.getElementById('stopLossSelect')?.value || 'recommended';
  const takeProfitMode = document.getElementById('takeProfitSelect')?.value || 'recommended';
  
  for (const row of rows) {
    try {
      // Add validation for crypto title to prevent USD-only errors
      const titleEl = row.querySelector('.crypto-title');
      if (!titleEl || titleEl.textContent.trim() === 'USD') {
        // Skip rows with missing title or standalone USD
        continue;
      }
      
      const cryptoName = titleEl.textContent.trim().toUpperCase() + "USD";
      const stopLossInput = row.querySelector('.stop-loss-input');
      const takeProfitInput = row.querySelector('.take-profit-input');
      
      if (!stopLossInput || !takeProfitInput) continue;
      
      // For recommended mode, fetch ROC data
      if (stopLossMode === 'recommended' || takeProfitMode === 'recommended') {
        try {
          const resp = await fetch(`/api/eval_roc?pair=${cryptoName}`);
          if (!resp.ok) continue;
          
          const data = await resp.json();
          
          // ---- STOP LOSS CALCULATION ----
          if (stopLossMode === 'recommended') {
            // Get the actual stop-loss percentage (default to 0.2% if not provided)
            const actualStopLossPercent = data.stop_loss_percent || 0.2;
            
            // Calculate DISPLAY value by ADDING the fee
            // This shows the user what they'll effectively lose including fees
            const displayStopLoss = actualStopLossPercent + feeRates.taker;
            
            // Set the stop-loss input with the display value
            stopLossInput.value = displayStopLoss.toFixed(1);
            
            // Store the actual value (without fee) as a data attribute
            // This will be used when placing the order
            stopLossInput.setAttribute('data-actual-value', actualStopLossPercent.toFixed(1));
            
            console.log(`${cryptoName} Stop Loss: Display ${displayStopLoss.toFixed(1)}%, Actual ${actualStopLossPercent.toFixed(1)}%`);
          }
          
          // ---- TAKE PROFIT CALCULATION ----
          if (takeProfitMode === 'recommended') {
            // Get the actual take-profit percentage (default to 1.16% if not provided)
            const actualTakeProfitPercent = data.take_profit_percent || 1.16;
            
            // Calculate DISPLAY value by SUBTRACTING the fee
            // This shows the user what they'll effectively gain after fees
            const displayTakeProfit = Math.max(0.1, actualTakeProfitPercent - feeRates.taker);
            
            // Set the take-profit input with the display value
            takeProfitInput.value = displayTakeProfit.toFixed(1);
            
            // Store the actual value (with fee) as a data attribute
            // This will be used when placing the order
            takeProfitInput.setAttribute('data-actual-value', actualTakeProfitPercent.toFixed(1));
            
            console.log(`${cryptoName} Take Profit: Display ${displayTakeProfit.toFixed(1)}%, Actual ${actualTakeProfitPercent.toFixed(1)}%`);
          }
        } catch (error) {
          console.error(`Error processing ${cryptoName}:`, error);
        }
      } 
      // For fixed mode, use saved values with fee adjustments
      else {
        if (stopLossMode === 'fixed') {
          const savedDisplayValue = localStorage.getItem('fixedStopLossValue') || '0.3';
          const displayValue = parseFloat(savedDisplayValue);
          
          // For stop-loss, actual value is display value MINUS fee
          const actualValue = Math.max(0.1, displayValue - feeRates.taker);
          
          stopLossInput.value = displayValue.toFixed(1);
          stopLossInput.setAttribute('data-actual-value', actualValue.toFixed(1));
        }
        
        if (takeProfitMode === 'fixed') {
          const savedDisplayValue = localStorage.getItem('takeProfitValue') || '1.16';
          const displayValue = parseFloat(savedDisplayValue);
          
          // For take-profit, actual value is display value PLUS fee
          const actualValue = displayValue + feeRates.taker;
          
          takeProfitInput.value = displayValue.toFixed(1);
          takeProfitInput.setAttribute('data-actual-value', actualValue.toFixed(1));
        }
      }
    } catch (error) {
      console.error('Error in fee-adjusted initialization:', error);
    }
  }
  
  console.log('Fee-adjusted initialization complete');
}

// Global initialization state
window.initializationState = {
    isInitializing: false,
    minimumAmountsSet: false,
    savedAmountApplied: false
};

document.addEventListener('DOMContentLoaded', refreshFeeAdjustedValues);
document.addEventListener('DOMContentLoaded', async function() {
    try {
      console.log('Setting up streamlined initialization process');
        
      // Initialize minimum amounts first (keep existing logic)
        await initializeMinimumAmounts();
    
      // Load saved preferences for Stop Loss and Take Profit modes
        const savedStopLossMode = localStorage.getItem('stopLossMode') || 'recommended';
        const savedTakeProfitMode = localStorage.getItem('takeProfitMode') || 'recommended';
        
        const stopLossSelect = document.getElementById('stopLossSelect');
        const takeProfitSelect = document.getElementById('takeProfitSelect');
        
        if (stopLossSelect) {
            stopLossSelect.value = savedStopLossMode;
            handleStopLossChange(savedStopLossMode);
        }
        
        if (takeProfitSelect) {
            takeProfitSelect.value = savedTakeProfitMode;
            handleTakeProfitChange(savedTakeProfitMode);
        }

      // Wait for UI changes to complete
      await new Promise(resolve => setTimeout(resolve, 300));
      
      // Run our centralized initialization once
      await initializeFeeAdjustedValues();

      // Initialize button states
        await initializeButtonStates();

    // Set up auto-refresh from saved preference
    const savedInterval = localStorage.getItem('autoRefreshInterval') || '0';
    const autoRefreshSelect = document.getElementById('autoRefreshSelect');
    if (autoRefreshSelect) {
        autoRefreshSelect.value = savedInterval;
        updateAutoRefresh(parseInt(savedInterval));
    }

      // Handle saved amount selection
      const savedAmount = localStorage.getItem("amountSelection");
      if (savedAmount) {
        const amountDropdown = document.getElementById("amountDropdown");
        if (amountDropdown) {
          amountDropdown.value = savedAmount;
          await applyAmountSelection(savedAmount);
                }
      }
      
      // Load active orders
        await loadActiveOrders();
        await applyFeeAdjustedValues();
        const feeRates = await getCurrentFeeRates();
        setupFeeAdjustedInputListeners(feeRates);

        setTimeout(() => {
            refreshRecommendedValues();
        }, 1000);
      
      console.log('Streamlined initialization completed');

    } catch (error) {
      console.error("Error during streamlined initialization:", error);
    }
  });

  async function refreshRecommendedValues() {
    try {
        console.log('Refreshing recommended values with improved ratio calculations');
        
        const stopLossMode = document.getElementById('stopLossSelect')?.value || 'recommended';
        const takeProfitMode = document.getElementById('takeProfitSelect')?.value || 'recommended';
        
        // Get fee rates once
        const feeRates = await getCurrentFeeRates();
        console.log(`Using fee rates - Maker: ${feeRates.maker}%, Taker: ${feeRates.taker}%`);
        
        const rows = document.querySelectorAll('#cryptoTableBody tr');
        for (const row of rows) {
            // Skip rows with missing title or standalone USD
            const titleEl = row.querySelector('.crypto-title');
            if (!titleEl || titleEl.textContent.trim() === 'USD') continue;
            
            const cryptoName = titleEl.textContent.trim().toUpperCase() + "USD";
            const stopLossInput = row.querySelector('.stop-loss-input');
            const takeProfitInput = row.querySelector('.take-profit-input');
            
            if (!stopLossInput || !takeProfitInput) continue;
            
            // Only process if at least one mode is recommended
            if (stopLossMode === 'recommended' || takeProfitMode === 'recommended') {
                // Get recommended stop loss value from High/Low data
                if (stopLossMode === 'recommended') {
                    const highLowCell = row.querySelector('td:nth-child(7)');
                    if (highLowCell) {
                        const highLowText = highLowCell.textContent;
                        // Extract the LOW value (after the pipe symbol)
                        const lowMatch = highLowText.match(/\| -(.+)%/);
                        
                        if (lowMatch && lowMatch[1]) {
                            const lowValue = parseFloat(lowMatch[1]);
                            if (!isNaN(lowValue)) {
                                // Use one-third of the low value, with fees added
                                // This becomes our display value
                                const recommendedStopLoss = Math.max(0.2, (lowValue / 3));
                                const displayStopLoss = recommendedStopLoss;
                                
                                // Calculate both stop-loss and take-profit with proper ratio
                                const values = await calculateFeeAdjustedStopLossAndTakeProfit(displayStopLoss);
                                
                                // Update stop-loss display and actual values
                                stopLossInput.value = values.displayStopLoss.toFixed(1);
                                stopLossInput.setAttribute('data-actual-value', values.actualStopLoss.toFixed(1));
                                stopLossInput.setAttribute('data-fee-adjusted', 'true');
                                
                                // If take-profit should also be updated
                                if (takeProfitMode === 'recommended') {
                                    takeProfitInput.value = values.displayTakeProfit.toFixed(1);
                                    takeProfitInput.setAttribute('data-actual-value', values.actualTakeProfit.toFixed(1));
                                    takeProfitInput.setAttribute('data-fee-adjusted', 'true');
                                }
                                
                                console.log(`${cryptoName}: Updated with ratio-preserving values`);
                            }
                        }
                    }
                }
                
                // If only take-profit is recommended (not handled above)
                else if (takeProfitMode === 'recommended' && stopLossMode !== 'recommended') {
                    const highLowCell = row.querySelector('td:nth-child(7)');
                    if (highLowCell) {
                        const highLowText = highLowCell.textContent;
                        // Extract the HIGH value (first percentage before the pipe symbol)
                        const highMatch = highLowText.match(/^([\d.]+)%/);
                        
                        if (highMatch && highMatch[1]) {
                            const highValue = parseFloat(highMatch[1]);
                            if (!isNaN(highValue)) {
                                // Take profit is half of the HIGH value
                                const actualTakeProfitValue = highValue / 2;
                                
                                // Calculate display value by subtracting fees
                                const displayTakeProfitValue = Math.max(0.1, actualTakeProfitValue - feeRates.taker);
                                
                                takeProfitInput.value = displayTakeProfitValue.toFixed(1);
                                takeProfitInput.setAttribute('data-actual-value', actualTakeProfitValue.toFixed(1));
                                takeProfitInput.setAttribute('data-fee-adjusted', 'true');
                            }
                        }
                    }
                }
            }
        }
        
        // Mark as applied 
        window.feeAdjustmentsApplied = true;
        
        // Use your existing protectFeeAdjustedInputs function
        protectFeeAdjustedInputs();
        
    } catch (error) {
        console.error('Error refreshing recommended values:', error);
    }
}

  function protectFeeAdjustedInputs() {
  // Check if adjustments have been applied
  if (!window.feeAdjustmentsApplied) return;
  
  // Get all fee-adjusted inputs
  const adjustedInputs = document.querySelectorAll('[data-fee-adjusted="true"]');
  
  // Save current values to restore if needed
  adjustedInputs.forEach(input => {
    const displayValue = input.value;
    const actualValue = input.getAttribute('data-actual-value');
    
    // Create a MutationObserver to watch for value changes
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        // If value attribute changes, check and restore if needed
        if (mutation.type === 'attributes' && mutation.attributeName === 'value') {
          const newValue = input.value;
          
          // If the value changed unexpectedly, restore it
          if (newValue !== displayValue) {
            console.log(`Prevented flickering: Restoring ${input.classList.contains('stop-loss-input') ? 'Stop Loss' : 'Take Profit'} from ${newValue} to ${displayValue}`);
            input.value = displayValue;
          }
        }
      });
    });
    
    // Observe value changes
    observer.observe(input, { attributes: true });
    
    // Store observer reference to disconnect later if needed
    input.observer = observer;
  });
  
  console.log(`Protected ${adjustedInputs.length} fee-adjusted inputs from flickering`);
}

function setupImprovedInputListeners() {
    // For stop-loss inputs
    document.querySelectorAll('.stop-loss-input').forEach(input => {
        // Remove existing listeners to avoid duplicates
        const newInput = input.cloneNode(true);
        input.parentNode.replaceChild(newInput, input);
        
        newInput.addEventListener('change', async function() {
            try {
                const displayValue = parseFloat(this.value);
                if (!isNaN(displayValue)) {
                    // Use our unified function
                    const values = await calculateFeeAdjustedStopLossAndTakeProfit(displayValue);
                    
                    // Update this input
                    this.value = values.displayStopLoss.toFixed(1);
                    this.setAttribute('data-actual-value', values.actualStopLoss.toFixed(1));
                    this.setAttribute('data-fee-adjusted', 'true');
                    
                    // Also update the paired take-profit input if it exists
                    const container = this.closest('tr') || this.closest('.crypto-item');
                    if (container) {
                        const takeProfitInput = container.querySelector('.take-profit-input');
                        if (takeProfitInput) {
                            takeProfitInput.value = values.displayTakeProfit.toFixed(1);
                            takeProfitInput.setAttribute('data-actual-value', values.actualTakeProfit.toFixed(1));
                            takeProfitInput.setAttribute('data-fee-adjusted', 'true');
                        }
                    }
                }
            } catch (error) {
                console.error('Error adjusting for fees:', error);
            }
        });
    });
    
    // For take-profit inputs - these follow stop-loss ratio
    document.querySelectorAll('.take-profit-input').forEach(input => {
        // Remove existing listeners to avoid duplicates
        const newInput = input.cloneNode(true);
        input.parentNode.replaceChild(newInput, input);
        
        newInput.addEventListener('change', async function() {
            try {
                const displayValue = parseFloat(this.value);
                if (!isNaN(displayValue)) {
                    // Get current fee rates
                    const feeRates = await getCurrentFeeRates();
                    
                    // This is independent of the ratio - user explicitly set take profit
                    const actualValue = displayValue + feeRates.taker;
                    this.setAttribute('data-actual-value', actualValue.toFixed(1));
                    this.setAttribute('data-fee-adjusted', 'true');
                }
            } catch (error) {
                console.error('Error adjusting take-profit for fees:', error);
            }
        });
    });
    
    console.log('Set up improved fee-adjusted input listeners with ratio preservation');
}

async function refreshPageData(force = false) {
    try {
        const timeSinceLastRefresh = Date.now() - lastRefreshTimestamp;
        if (!force && timeSinceLastRefresh < MIN_REFRESH_INTERVAL) {
            console.log('Skipping refresh - less than 2 minutes since last refresh');
            return;
        }

        if (autoTradeActive) {
            const button = document.querySelector('.trading-button[onclick*="toggleAutoTrade"]');
            if (button) {
            button.textContent = 'Updating Data...';
            }
            isRefreshingData = true;
        }

        // Fetch only the updated crypto data instead of the entire page
        const response = await fetch('/update');
        const data = await response.json();
        
        if (!data.cryptos) {
            throw new Error('No crypto data received from server');
        }

        const currentTableBody = document.getElementById('cryptoTableBody');
        currentTableBody.innerHTML = ''; // Clear existing content

        // Render new rows using the template structure from index.html
        data.cryptos.forEach(async (crypto, index) => {
            const row = document.createElement('tr');
            row.setAttribute('data-row-id', `row-${index}`);
            
            // Set background color based on tier
            if (crypto.pair in tier1_cryptos) {
                row.style.backgroundColor = '#066c41';
            } else if (crypto.pair in tier2_cryptos) {
                row.style.backgroundColor = '#725f00';
            }

            // Add the row content using the same structure as the template
            row.innerHTML = `
                <td style="height: 50px;">
                    <div style="display: flex; align-items: center; height: 100%;">
                        <div style="width: 30px; display: flex; align-items: center; justify-content: center;">
                            <span class="chart-expander" style="cursor: pointer; transition: transform 0.3s ease;" onclick="toggleCryptoChart(this)">â–¶</span>
                        </div>
                        <div style="flex-grow: 1; display: flex; flex-direction: column; justify-content: center; align-items: center;">
                            <div id="crypto-name-${index}"></div>
                        </div>
                    </div>
                </td>
                <td>${crypto.price.toFixed(4)}</td>
                <td>${crypto.avg_roc.toFixed(3)}% 
                    ${crypto.current_trend === "up" ? '<span class="trend-up">â–²</span>' :
                      crypto.current_trend === "down" ? '<span class="trend-down">â–¼</span>' :
                      '<span class="neutral">-</span>'}
                </td>
                <td>${crypto.roc_activity.toFixed(2)}</td>
                <td>$${(crypto.volume / 1_000_000).toFixed(1)}M</td>
                <td>${crypto.one_percent_gain}</td>
                <td>${crypto.high_low}</td>
                <td id="optimal-time-${crypto.pair}"></td>
                <td class="trade-cell" style="height: 50px; padding: 10px 0;">
                <div style="display: flex; align-items: flex-end; gap: 10px; height: 100%;">
                    <div style="display: flex; flex-direction: column; gap: 2px;">
                        <label style="font-size: 0.8em;">Loss %</label>
                        <input type="text" class="stop-loss-input" style="width: 4ch; padding: 4px 6px;">
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 2px;">
                        <label style="font-size: 0.8em;">Profit %</label>
                        <input type="text" class="take-profit-input" style="width: 4ch; padding: 4px 6px;">
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 2px;">
                        <label style="font-size: 0.8em;">Amount</label>
                        <input type="number" value="20" style="width: 10ch; padding: 4px 6px;">
                    </div>
                    <button
                        style="
                            background-color: green;
                            color: white;
                            border: none;
                            border-radius: 0;
                            height: 30px;
                            padding: 5px 15px;
                            cursor: pointer;
                            text-transform: uppercase;
                            align-self: flex-end;
                        "
                        onmouseover="this.style.backgroundColor='darkgreen';"
                        onmouseout="this.style.backgroundColor='green';"
                        onclick="updateTakeProfitAndPlaceOrder(this)"
                    >
                        Trade
                    </button>
                    <button 
                        class="custom-trade-btn buy-btn"
                        onmouseover="this.style.backgroundColor='#005599';"
                        onmouseout="this.style.backgroundColor='#0077cc';"
                        onclick="customBuyHandler(this)"
                    >
                        BUY
                    </button>
                    <button 
                        class="custom-trade-btn sell-btn"
                        onmouseover="this.style.backgroundColor='#ea580c';"
                        onmouseout="this.style.backgroundColor='#f97316';"
                        onclick="customSellHandler(this)"
                    >
                        SELL
                    </button>
                    <div class="status-container" style="align-self: flex-end; height: 30px; display: flex; align-items: center;">
                        <div class="polling-dot"></div>
                        <span class="buyOrderStatus" style="display: none;"></span>
                        <span class="status-text">Inactive</span>
                    </div>
                </div>
                </td>
            `;
            
            currentTableBody.appendChild(row);

            // Initialize React component for crypto name
            const nameEl = document.getElementById(`crypto-name-${index}`);
            if (nameEl) {
                ReactDOM.createRoot(nameEl).render(React.createElement(CryptoName, {
                    name: crypto.pair,
                    conditions: crypto.conditions
                }));
            }

            // Check for minimum amounts immediately after adding the row
            try {
                const resp = await fetch(`/api/eval_roc?pair=${crypto.pair}USD`);
                if (resp.ok) {
                    const data = await resp.json();
                    if (data.min_usd) {
                        const amountInput = row.querySelector('input[type="number"]');
                        const amountLabel = amountInput.previousElementSibling;
                        
                        if (amountInput && amountLabel) {
                            amountInput.value = data.min_usd;
                            amountInput.min = data.min_usd;
                            amountLabel.innerHTML = '<span style="color: red; font-weight: bold; background: black; padding: 2px 4px;">MINIMUM</span>';
                            
                            amountInput.addEventListener('change', function() {
                                if (parseFloat(this.value) < data.min_usd) {
                                    this.value = data.min_usd;
                                    alert(`This cryptocurrency requires a minimum order of $${data.min_usd}`);
                                }
                            });
                        }
                    }
                }
            } catch (err) {
                console.error(`Error checking minimums for ${crypto.pair}:`, err);
            }
        });

        lastRefreshTimestamp = Date.now();
        setupAmountInputListeners();

        setTimeout(async () => {
            await refreshAllLimits();
            
            if (autoTradeActive) {
                const button = document.querySelector('.auto-trade-button');
                button.textContent = 'Stop Auto-Trade';
                isRefreshingData = false;
            }
        }, 500);
        
    } catch (error) {
        console.error('Error refreshing data:', error);
        if (autoTradeActive) {
            const button = document.querySelector('.trading-button[onclick*="toggleAutoTrade"]');
            if (button) {
            button.textContent = 'Stop Auto-Trade';
            }
            isRefreshingData = false;
        }
    }
}

async function customBuyHandler(button) {
    const container = button.closest('tr') || button.closest('.crypto-item');
    if (!container) return;

    const rowId = container.getAttribute('data-row-id');
    const statusDiv = container.querySelector('.buyOrderStatus');
    const defaultText = container.querySelector('.status-text');

    try {
        const state = order_states[rowId];
        
        // If sell order is open, flash red and do nothing
        if (state && state.status === 'sell_open') {
            flashButton(button, 'red');
            return;
        }

        // Store original button text and style
        const originalText = button.textContent;
        const originalStyle = button.style.backgroundColor;

        // Update button state to show buying
        button.disabled = true;
        button.textContent = "BUYING...";
        button.style.backgroundColor = "grey";

        // If buy order is open, cancel and market buy
        if (state && state.status === 'buy_open') {
            try {
                await cancelOrder(container.querySelector('button.cancel-button'));
            } catch (cancelError) {
                console.error('Error cancelling order:', cancelError);
            }
        }

        // Proceed with market buy
        try {
            await marketBuy(button);
            
            // Reset button text and style after buy is complete
            button.textContent = originalText;
            button.style.backgroundColor = originalStyle;
            button.disabled = false;
            
        } catch (buyError) {
            console.error('Error executing market buy:', buyError);
            // Reset button state on error
            button.textContent = originalText;
            button.style.backgroundColor = originalStyle;
            button.disabled = false;
            flashButton(button, 'red');
        }

    } catch (error) {
        console.error('Error in customBuyHandler:', error);
        // Reset button to original state
        button.textContent = "BUY";
        button.style.backgroundColor = "#0077cc";
        button.disabled = false;
        flashButton(button, 'red');
    }
}

// In index.html
async function customSellHandler(button) {
    const container = button.closest('tr') || button.closest('.crypto-item');
    if (!container) return;

    const rowId = container.getAttribute('data-row-id');
    const cryptoName = container.querySelector('.crypto-title').textContent.trim();
    const statusDiv = container.querySelector('.status-text');

    try {
        // Store original button text
        const originalText = button.textContent;
        button.disabled = true;
        button.textContent = "SELLING...";
        
        // 1. Cancel the current Sell order if there's one
        const state = order_states[rowId];
        if (state && (state.status === 'sell_open' || state.status === 'buy_open')) {
            try {
                await cancelOrder(container.querySelector('button.cancel-button'));
                // Wait for cancel to complete
                await new Promise(resolve => setTimeout(resolve, 1000));
            } catch (cancelError) {
                console.error('Error cancelling order:', cancelError);
            }
        }

        // 2. Execute market sell
        const result = await marketSell(button);
        
        // 3. Wait for trade completion and display status
        if (result && result.status === 'success') {
            statusDiv.textContent = `Trade Completed [${result.percent_gain > 0 ? '+' : ''}${result.percent_gain.toFixed(2)}%]`;
            
            // 4. Change Trade button to Reset
            const tradeButton = container.querySelector('.trade-button');
            if (tradeButton) {
                tradeButton.textContent = "Reset";
                tradeButton.onclick = function() {
                    resetCryptoRow(container);
                };
            }
        }
        
        // Reset sell button
        button.disabled = false;
        button.textContent = originalText;
        
    } catch (error) {
        console.error('Error in customSellHandler:', error);
        button.disabled = false;
        button.textContent = "SELL";
        flashButton(button, 'red');
    }
}

// Add a new function to reset the crypto row
function resetCryptoRow(container) {
    const rowId = container.getAttribute('data-row-id');
    const statusDiv = container.querySelector('.status-text');
    const tradeButton = container.querySelector('.trade-button');
    
    // Reset status text
    if (statusDiv) {
        statusDiv.textContent = "Inactive";
    }
    
    // Reset trade button
    if (tradeButton) {
        tradeButton.textContent = "Trade";
        tradeButton.onclick = function() {
            placeTrailingStopBuy(this);
        };
    }
    
    // Clear order state
    if (order_states[rowId]) {
        delete order_states[rowId];
    }
}

function flashButton(button, color) {
    const originalBackground = button.style.backgroundColor;
    button.style.backgroundColor = color;
    setTimeout(() => {
        button.style.backgroundColor = originalBackground;
    }, 300);
}

function updateTableWithNewData(cryptos) {
    const currentTableBody = document.getElementById('cryptoTableBody');
    if (!currentTableBody) return;

    // Clear existing content
    currentTableBody.innerHTML = '';

    // Rebuild table with new data
    cryptos.forEach((crypto, index) => {
        const row = document.createElement('tr');
        row.setAttribute('data-row-id', `row-${index}`);
        
        // Set background color based on conditions
        if (crypto.conditions && Object.values(crypto.conditions).some(v => v)) {
            row.style.backgroundColor = '#066c41';
        }

        // Add row content (simplified version)
        row.innerHTML = `
            <td>
                <div id="crypto-name-${index}"></div>
            </td>
            <td>${crypto.price.toFixed(4)}</td>
            <td>${crypto.avg_roc.toFixed(3)}%</td>
            <td>${crypto.roc_activity.toFixed(2)}</td>
            <td>$${(crypto.volume / 1_000_000).toFixed(1)}M</td>
            <td>${crypto.one_percent_gain}</td>
            <td>${crypto.high_low}</td>
            <td>${crypto.time_window || ''}</td>
            <!-- Trade cell content -->
        `;

        currentTableBody.appendChild(row);

        // Initialize React components
        const nameEl = document.getElementById(`crypto-name-${index}`);
        if (nameEl) {
            ReactDOM.createRoot(nameEl).render(
                React.createElement(CryptoName, {
                    name: crypto.pair,
                    conditions: crypto.conditions
                })
            );
        }
    });

    setupAmountInputListeners();
    // Reinitialize all components and event listeners
    initializeButtonStates();
    refreshAllLimits();
}

// Add these to the window scope for accessibility
window.customBuyHandler = customBuyHandler;
window.customSellHandler = customSellHandler;

// In index.html
async function executeAutoTrade() {
    if (!autoTradeActive) return;
    
    try {
        // Find the best crypto to trade
        const bestRow = findBestCryptoToTrade();
        if (!bestRow) {
            console.log('No suitable crypto found for trading');
            await refreshPageData(true);
            setTimeout(executeAutoTrade, 5000);
            return;
        }

        // Start the trade
        const tradeButton = bestRow.querySelector('button.trade-button');
        if (tradeButton) {
            const rowId = bestRow.getAttribute('data-row-id');
            currentAutoTradeId = rowId;
            
            const cryptoName = bestRow.querySelector('.crypto-title')?.textContent;
            console.log('Starting auto-trade for:', cryptoName);
            
            // 1. Open a trade (click the Trade button)
            tradeButton.click();
            
            // 2. Wait for trade completion (both buy and sell)
            const status = await waitForTradeCompletion(rowId);
            console.log('Trade cycle ended with status:', status);
            
            // 3. After trade completion, wait 10 seconds and reload
            if (autoTradeActive) {
                console.log('Trade completed, waiting 10 seconds before reloading...');
                
                // Save auto-trade state before reload
                localStorage.setItem('autoTradeActive', 'true');
                
                // Wait 10 seconds
                await new Promise(resolve => setTimeout(resolve, 10000));
                
                // Reload the page
                window.location.reload();
            }
        }
    } catch (error) {
        console.error('Error in auto-trade cycle:', error);
        if (autoTradeActive) {
            await refreshPageData(true);
            setTimeout(executeAutoTrade, 5000);
        }
    }
}

// Improve the waitForTradeCompletion function
async function waitForTradeCompletion(rowId) {
    return new Promise((resolve) => {
        const checkStatus = setInterval(async () => {
            if (!autoTradeActive) {
                clearInterval(checkStatus);
                resolve('stopped');
                return;
            }

            try {
                const response = await fetch(`/order/status/${rowId}`);
                const state = await response.json();
                
                // Consider trade complete if status is completed
                if (state.status === 'completed') {
                    clearInterval(checkStatus);
                    resolve('completed');
                }
                // Handle manual interventions (BUY/SELL buttons)
                else if (state.status === 'market_sell_executing' || 
                         state.status === 'market_buy_executing') {
                    // Continue monitoring but don't resolve yet
                }
                // Handle other completion states
                else if (state.status === 'error' || 
                         state.status === 'cancelled' ||
                         !state.status) {
                    clearInterval(checkStatus);
                    resolve(state.status || 'unknown');
                }
            } catch (error) {
                console.error('Error checking trade status:', error);
                // On error, keep trying
            }
        }, 3000); // Check every 3 seconds
    });
}

let lastTradedCrypto = null;
let lastTradeOutcome = null;

// Helper function to check if crypto is trending up
function isCryptoTrendingUp(row) {
    const rocCell = row.querySelector('td:nth-child(3)');
    const trendArrow = rocCell?.querySelector('.trend-up');
    const rocValue = parseFloat(rocCell?.textContent);
    return trendArrow && rocValue > 0;
}

// Helper function to find the best crypto to trade
function findBestCryptoToTrade() {
    const rows = document.querySelectorAll('#cryptoTableBody tr');
    console.log('Searching for best crypto to trade among', rows.length, 'rows');
    
    // Find all active rows that don't have ongoing trades
    const availableRows = Array.from(rows).filter(row => {
        const statusText = row.querySelector('.status-text')?.textContent;
        const buyOrderStatus = row.querySelector('.buyOrderStatus')?.textContent;
        const cryptoName = row.querySelector('.crypto-title')?.textContent;
        
        // Skip if this was the last traded crypto with negative outcome
        if (lastTradeOutcome === false && cryptoName === lastTradedCrypto) {
            return false;
        }
        
        return statusText === 'Inactive' || !buyOrderStatus;
    });
    
    if (availableRows.length === 0) {
        console.log('No available rows for trading');
        return null;
    }
    
    // If last trade was negative, prioritize trending up cryptos
    if (lastTradeOutcome === false) {
        console.log('Last trade was negative, looking for trending up cryptos');
        
        // First priority: Green background (2+ conditions) AND trending up
        const greenTrendingUp = availableRows.find(row => {
            const bgColor = row.style.backgroundColor;
            return bgColor === 'rgb(6, 108, 65)' && isCryptoTrendingUp(row);
        });
        
        if (greenTrendingUp) {
            console.log('Found qualifying trending up crypto with green background');
            return greenTrendingUp;
        }
        
        // Second priority: Yellow background AND trending up
        const yellowTrendingUp = availableRows.find(row => {
            const bgColor = row.style.backgroundColor;
            return bgColor === 'rgb(114, 95, 0)' && isCryptoTrendingUp(row);
        });
        
        if (yellowTrendingUp) {
            console.log('Found qualifying trending up crypto with yellow background');
            return yellowTrendingUp;
        }
        
        // Third priority: Any trending up crypto
        const anyTrendingUp = availableRows.find(row => isCryptoTrendingUp(row));
        if (anyTrendingUp) {
            console.log('Found any trending up crypto');
            return anyTrendingUp;
        }
    }
    
    // Normal priority selection if last trade was positive or no trending up cryptos found
    // Look for rows with green background (2 or more conditions met)
    for (const row of availableRows) {
        const bgColor = row.style.backgroundColor;
        const cryptoName = row.querySelector('.crypto-title')?.textContent;
        
        if (bgColor === 'rgb(6, 108, 65)') {  // #066c41 in RGB
            console.log('Found qualifying crypto:', cryptoName);
            return row;
        }
    }
    
    // Second priority: yellow background (tier2)
    for (const row of availableRows) {
        const bgColor = row.style.backgroundColor;
        if (bgColor === 'rgb(114, 95, 0)') {  // #725f00 in RGB
            const cryptoName = row.querySelector('.crypto-title')?.textContent;
            console.log('Found tier 2 crypto:', cryptoName);
            return row;
        }
    }
    
    // If no highlighted cryptos found, use the first available row
    const firstRow = availableRows[0];
    if (firstRow) {
        const cryptoName = firstRow.querySelector('.crypto-title')?.textContent;
        console.log('No qualifying cryptos found, using highest volume:', cryptoName);
        return firstRow;
    }
    
    return null;
}

function toggleDayDetails(dateKey) {
    const allDayDetails = document.querySelectorAll('.day-details');
    const allDayArrows = document.querySelectorAll('[id^="arrow-"]');
    const currentDetails = document.getElementById(`details-${dateKey}`);
    const currentArrow = document.getElementById(`arrow-${dateKey}`);
    
    // Hide other day details
    allDayDetails.forEach(detail => {
        if (detail !== currentDetails) {
            detail.classList.remove('open');
                    detail.style.display = 'none';
                }
    });
    
    // Reset other day arrows
    allDayArrows.forEach(arrow => {
        if (arrow !== currentArrow && !arrow.id.startsWith('arrow-month-')) {
            arrow.classList.remove('open');
        }
    });
    
    // Toggle current details
    if (!currentDetails.classList.contains('open')) {
        currentDetails.style.display = 'table-row';
        setTimeout(() => currentDetails.classList.add('open'), 10);
    } else {
        currentDetails.classList.remove('open');
        setTimeout(() => currentDetails.style.display = 'none', 200);
    }
    
    currentArrow.classList.toggle('open');
    event.stopPropagation();
}

function toggleAutoTrade() {
    try {
        const button = document.querySelector('.trading-button[onclick*="toggleAutoTrade"]');
        if (!button) {
            console.error('Auto-trade button not found');
            return;
        }

        autoTradeActive = !autoTradeActive;
        
        if (autoTradeActive) {
            button.textContent = 'Stop Auto-Trade';
            button.classList.add('active');
            button.style.backgroundColor = '#dc3545';
            executeAutoTrade();
        } else {
            button.textContent = 'Auto-Trade';
            button.classList.remove('active');
            button.style.backgroundColor = '#ff8c00';
            currentAutoTradeId = null;
        }
    } catch (error) {
        console.error('Error in toggleAutoTrade:', error);
        autoTradeActive = false;
    }
}

document.addEventListener('DOMContentLoaded', function() {
    loadActiveOrders();
    setupAmountInputListeners();
    // Helper function to safely get DOM elements
    function getElement(id, contextMessage) {
        const element = document.getElementById(id);
        if (!element) {
            console.error(`${contextMessage}: Could not find element with id "${id}"`);
            return null;
        }
        return element;
    }

    // Helper function to validate numeric ranges
    function isValidPercentage(value, min = 0.1, max = 10) {
        const num = parseFloat(value);
        return !isNaN(num) && num >= min && num <= max;
    }

    // Get DOM elements with error handling
    const stopLossSelect = getElement('stopLossSelect', 'Stop Loss initialization');
    const fixedStopLossControls = getElement('fixedStopLossControls', 'Stop Loss controls');
    const fixedStopLossValue = getElement('fixedStopLossValue', 'Stop Loss value input');
    const applyStopLoss = getElement('applyStopLoss', 'Stop Loss apply button');
    const takeProfitSelect = getElement('takeProfitSelect', 'Take Profit initialization');
    const takeProfitControls = getElement('takeProfitControls', 'Take Profit controls');
    const takeProfitValue = getElement('takeProfitValue', 'Take Profit value input');
    const applyTakeProfitBtn = getElement('applyTakeProfit', 'Take Profit apply button');

    // Exit if critical elements are missing
    if (!stopLossSelect || !takeProfitSelect) {
        console.error('Critical DOM elements missing. Initialization aborted.');
        return;
    }

    // Add event listeners to amount fields to update fee-adjusted values when they change
    document.querySelectorAll('input[type="number"]').forEach(input => {
        input.addEventListener('change', function() {
            // After a short delay to allow other processes to complete
            setTimeout(() => {
            // First refresh recommended values with fee adjustments included
            refreshRecommendedValues().then(() => {
            // Then protect those values from being overwritten
            protectFeeAdjustedInputs();
            // And set up improved listeners for manual changes
            setupImprovedInputListeners();
            });
        }, 1000); 
        });
    });

    // Default values
    const DEFAULT_TAKE_PROFIT = '1.16';
    const DEFAULT_STOP_LOSS = '0.3';

    // Load and validate saved preferences
    const savedStopLossMode = localStorage.getItem('stopLossMode') || 'recommended';
    const savedTakeProfitMode = localStorage.getItem('takeProfitMode') || 'recommended';
    let savedStopLossValue = localStorage.getItem('fixedStopLossValue');
    let savedTakeProfitValue = localStorage.getItem('takeProfitValue');

    // Validate saved values or use defaults
    if (!isValidPercentage(savedStopLossValue)) {
        savedStopLossValue = DEFAULT_STOP_LOSS;
        localStorage.setItem('fixedStopLossValue', DEFAULT_STOP_LOSS);
    }
    if (!isValidPercentage(savedTakeProfitValue)) {
        savedTakeProfitValue = DEFAULT_TAKE_PROFIT;
        localStorage.setItem('takeProfitValue', DEFAULT_TAKE_PROFIT);
    }
    // Initialize Stop Loss
    if (stopLossSelect && fixedStopLossValue) {
        stopLossSelect.value = savedStopLossMode;
        fixedStopLossValue.value = savedStopLossValue;
        handleStopLossChange(savedStopLossMode);

        // If mode is fixed, immediately apply the saved value to all fields
        if (savedStopLossMode === 'fixed') {
            const stopLossInputs = document.querySelectorAll('.stop-loss-input');
            stopLossInputs.forEach(input => {
                input.value = savedStopLossValue;
            });
        }
    }

    // Initialize Take Profit
    if (takeProfitSelect && takeProfitValue) {
        takeProfitSelect.value = savedTakeProfitMode;
        takeProfitValue.value = savedTakeProfitValue;
        handleTakeProfitChange(savedTakeProfitMode);

        // If mode is fixed, immediately apply the saved value to all fields
        if (savedTakeProfitMode === 'fixed') {
            const takeProfitInputs = document.querySelectorAll('.take-profit-input');
            takeProfitInputs.forEach(input => {
                input.value = savedTakeProfitValue;
            });
        }
    }

    // Load saved sell type preference
    const savedSellType = localStorage.getItem('sellType') || 'market';
    const sellTypeDropdown = document.getElementById('sellTypeDropdown');
    if (sellTypeDropdown) {
        sellTypeDropdown.value = savedSellType;
    }

    // Sync recommended values on page load
    if (savedStopLossMode === 'recommended' || savedTakeProfitMode === 'recommended') {
        setTimeout(() => {
            // First refresh recommended values with fee adjustments included
            refreshRecommendedValues().then(() => {
            // Then protect those values from being overwritten
            protectFeeAdjustedInputs();
            // And set up improved listeners for manual changes
            setupImprovedInputListeners();
            });
        }, 1000); 
    }

    // Event Listeners with error handling
    if (stopLossSelect) {
        stopLossSelect.addEventListener('change', function() {
            const mode = this.value;
            handleStopLossChange(mode);
            localStorage.setItem('stopLossMode', mode);
            if (mode === 'recommended') {
                refreshRecommendedValues();
                // Reapply take profit visibility after refreshing values
                handleTakeProfitChange(takeProfitSelect.value);
            }
        });
    }

    if (takeProfitSelect) {
        takeProfitSelect.addEventListener('change', function() {
            const mode = this.value;
            handleTakeProfitChange(mode);
            localStorage.setItem('takeProfitMode', mode);
            if (mode === 'recommended') {
                refreshRecommendedValues();
            }
        });
    }

    function setupAmountInputListeners() {
    // Find all amount input fields in the table
    const amountInputs = document.querySelectorAll('.trade-cell input[type="number"]');
    
    amountInputs.forEach(input => {
        // Remove any existing listeners to avoid duplicates
        input.removeEventListener('change', handleAmountChange);
        input.removeEventListener('blur', handleAmountChange);
        
        // Add listeners for both change and blur events
        input.addEventListener('change', handleAmountChange);
        input.addEventListener('blur', handleAmountChange);
    });
}

async function handleAmountChange(event) {
    try {
        const amountInput = event.target;
        const container = amountInput.closest('tr') || amountInput.closest('.crypto-item');
        if (!container) return;
        
        const stopLossInput = container.querySelector('.stop-loss-input');
        const takeProfitInput = container.querySelector('.take-profit-input');
        const titleEl = container.querySelector('.crypto-title');
        
        if (!stopLossInput || !takeProfitInput || !titleEl) return;
        
        const cryptoName = titleEl.textContent.trim().toUpperCase() + "USD";
        const newAmount = parseFloat(amountInput.value);
        
        if (isNaN(newAmount) || newAmount <= 0) return;
        
        // Always get current fee rates
        const feeRates = await getCurrentFeeRates();
        console.log(`Fees for ${newAmount} USD of ${cryptoName}: Maker ${feeRates.maker}%, Taker ${feeRates.taker}%`);
        
        const stopLossMode = document.getElementById('stopLossSelect')?.value || 'recommended';
        const takeProfitMode = document.getElementById('takeProfitSelect')?.value || 'recommended';
        
        // Create a function to store and restore original values
        const createValueTracker = (input) => {
            if (!input.hasAttribute('data-original-value')) {
                const originalActualValue = input.getAttribute('data-actual-value') || input.value;
                input.setAttribute('data-original-value', originalActualValue);
            }
            return () => {
                const originalValue = input.getAttribute('data-original-value');
                input.value = originalValue;
                input.setAttribute('data-actual-value', originalValue);
            };
        };
        
        const restoreStopLossValue = createValueTracker(stopLossInput);
        const restoreTakeProfitValue = createValueTracker(takeProfitInput);

        // For recommended mode, fetch ROC data
        if (stopLossMode === 'recommended' || takeProfitMode === 'recommended') {
            try {
                const resp = await fetch(`/api/eval_roc?pair=${cryptoName}`);
                if (resp.ok) {
                    const data = await resp.json();
                    
                    // Process stop loss for recommended mode
                    if (stopLossMode === 'recommended' && data.stop_loss_percent) {
                        const actualStopLoss = data.stop_loss_percent;
                        const displayStopLoss = Math.max(0.1, actualStopLoss + feeRates.taker);
                        
                        stopLossInput.setAttribute('data-actual-value', actualStopLoss.toFixed(1));
                        stopLossInput.value = displayStopLoss.toFixed(1);
                    }
                    
                    // Process take profit for recommended mode
                    if (takeProfitMode === 'recommended' && data.take_profit_percent) {
                        const actualTakeProfit = data.take_profit_percent;
                        const displayTakeProfit = Math.max(0.1, actualTakeProfit - feeRates.taker);
                        
                        takeProfitInput.setAttribute('data-actual-value', actualTakeProfit.toFixed(1));
                        takeProfitInput.value = displayTakeProfit.toFixed(1);
                    }

                    // Prevent immediate reversion by delaying restoration
                    setTimeout(() => {
                        // Double-check if the values are still fee-adjusted
                        const currentStopLossValue = parseFloat(stopLossInput.value);
                        const currentTakeProfitValue = parseFloat(takeProfitInput.value);
                        
                        if (Math.abs(currentStopLossValue - displayStopLoss) < 0.01) {
                            restoreStopLossValue();
                        }
                        
                        if (Math.abs(currentTakeProfitValue - displayTakeProfit) < 0.01) {
                            restoreTakeProfitValue();
                    }
                    }, 2000);
                }
            } catch (error) {
                console.error(`Error fetching updated ROC data for ${cryptoName}:`, error);
                // Restore original values on error
                restoreStopLossValue();
                restoreTakeProfitValue();
            }
        } else {
            // For fixed mode, use the original/actual values with current fee adjustments
            const restoreValues = () => {
            const actualStopLoss = parseFloat(stopLossInput.getAttribute('data-original-value'));
                const actualTakeProfit = parseFloat(takeProfitInput.getAttribute('data-original-value'));
                
            if (!isNaN(actualStopLoss)) {
                stopLossInput.setAttribute('data-actual-value', actualStopLoss.toFixed(1));
                stopLossInput.value = (actualStopLoss + feeRates.taker).toFixed(1);
            }
            
            if (!isNaN(actualTakeProfit)) {
                takeProfitInput.setAttribute('data-actual-value', actualTakeProfit.toFixed(1));
                takeProfitInput.value = Math.max(0.1, actualTakeProfit - feeRates.taker).toFixed(1);
            }
            };
            
            restoreValues();
        }
    } catch (error) {
        console.error('Error updating fees based on amount change:', error);
    }
}

    // Input validation with improved error handling
    function validateNumericInput(input, defaultValue) {
        try {
            input.value = input.value.replace(/[^\d.]/g, '');
            const parts = input.value.split('.');
            if (parts.length > 2) {
                input.value = parts[0] + '.' + parts.slice(1).join('');
            }
            if (input.value.length > 5) {
                input.value = input.value.slice(0, 5);
            }
            if (!isValidPercentage(input.value)) {
                input.value = defaultValue;
            }
        } catch (error) {
            console.error('Error validating input:', error);
            input.value = defaultValue;
        }
    }

    if (fixedStopLossValue) {
        fixedStopLossValue.addEventListener('input', function() {
            localStorage.setItem('fixedStopLossValue', this.value);
        });
    }

    if (takeProfitValue) {
        takeProfitValue.addEventListener('input', function() {
            validateNumericInput(this, DEFAULT_TAKE_PROFIT);
            localStorage.setItem('takeProfitValue', this.value);
        });
    }

    // Apply button handlers with error checking
    if (applyStopLoss) {
        applyStopLoss.addEventListener('click', function() {
            if (!isValidPercentage(fixedStopLossValue.value)) {
                alert('Please enter a valid stop loss percentage (0.1% - 10%)');
                fixedStopLossValue.value = DEFAULT_STOP_LOSS;
                return;
            }
            applyFixedStopLoss();
        });
    }

    if (applyTakeProfitBtn) {
        applyTakeProfitBtn.addEventListener('click', function() {
            if (!isValidPercentage(takeProfitValue.value)) {
                alert('Please enter a valid take profit percentage (0.1% - 10%)');
                takeProfitValue.value = DEFAULT_TAKE_PROFIT;
                return;
            }
            applyTakeProfit();
        });
    }

    // Initialize price trackers for each row
    document.querySelectorAll('[data-row-id]').forEach(row => {
        const rowId = row.getAttribute('data-row-id');
        const statusContainer = row.querySelector('.status-container');
        
        if (statusContainer) {
            const root = document.createElement('div');
            root.id = `price-tracker-${rowId}`;
            statusContainer.appendChild(root);
            
            createRoot(root).render(
                React.createElement(PriceTracker, {
                    rowId: rowId,
                    orderType: statusContainer.querySelector('.buyOrderStatus')?.textContent.toLowerCase().includes('buy') ? 'buy' : 'sell'
                })
            );
        }
    });
    // Initialize optimal time displays
    document.querySelectorAll('[id^="optimal-time-"]').forEach(element => {
        const pair = element.id.replace('optimal-time-', '');
        ReactDOM.createRoot(element).render(
            React.createElement(OptimalTimeDisplay, { pair: pair })
        );
    });

    // Check if auto-trade was active before reload
    if (localStorage.getItem('autoTradeActive') === 'true') {
        console.log('Restoring auto-trade state after reload...');
        setTimeout(() => {
            // Simulate click on auto-trade button to reactivate
            const autoTradeButton = document.querySelector('.trading-button[onclick*="toggleAutoTrade"]');
            if (autoTradeButton) {
                autoTradeButton.click();
                // Clear the stored state after reactivating
                localStorage.removeItem('autoTradeActive');
            }
        }, 2000); // Give page time to fully initialize
    }

    // Restore last trade state after page reload
    if (localStorage.getItem('autoTradeActive') === 'true') {
        lastTradedCrypto = localStorage.getItem('lastTradedCrypto');
        lastTradeOutcome = localStorage.getItem('lastTradeOutcome') === 'true';
        
        // Clear stored state after retrieving
        localStorage.removeItem('lastTradedCrypto');
        localStorage.removeItem('lastTradeOutcome');
        
        console.log('Restored last trade state:', {
            lastTradedCrypto,
            lastTradeOutcome
        });
    }

    document.querySelectorAll('.stop-loss-input, .take-profit-input').forEach(input => {
        input.addEventListener('change', async function() {
            // Get current fee rates
            const feeRates = await getCurrentFeeRates();
            
            // Handle stop-loss input
            if (this.classList.contains('stop-loss-input')) {
                const displayValue = parseFloat(this.value);
                if (!isNaN(displayValue)) {
                    // Convert display to actual by subtracting fee
                    const actualValue = await calculateFeeAdjustedStopLoss(displayValue);
                    // Store actual value
                    this.setAttribute('data-actual-value', actualValue.toFixed(1));
                }
            }
            
            // Handle take-profit input
            if (this.classList.contains('take-profit-input')) {
                const displayValue = parseFloat(this.value);
                if (!isNaN(displayValue)) {
                    // Convert display to actual by adding fee
                    const actualValue = await calculateFeeAdjustedTakeProfit(displayValue);
                    // Store actual value
                    this.setAttribute('data-actual-value', actualValue.toFixed(1));
                }
            }
        });
    });

});

function handleTakeProfitChange(mode) {
    const controls = document.getElementById('takeProfitControls');
    const takeProfitInputs = document.querySelectorAll('.take-profit-input');
    const takeProfitContainers = document.querySelectorAll('.trade-cell div:has(.take-profit-input)');
    
    switch (mode) {
        case 'recommended':
            controls.style.display = 'none';
            takeProfitContainers.forEach(container => {
                container.style.display = 'flex';
            });
            takeProfitInputs.forEach(input => {
                input.style.display = '';
                input.previousElementSibling.style.visibility = 'visible';
            });
            refreshRecommendedTakeProfits();
            break;

            
        case 'fixed':
            controls.style.display = 'inline-block';
            takeProfitContainers.forEach(container => {
                container.style.display = 'flex';
            });
            takeProfitInputs.forEach(input => {
                input.style.display = '';
                input.previousElementSibling.style.visibility = 'visible';
            });
            break;
    }
}

async function refreshRecommendedTakeProfits() {
    try {
        const rows = document.querySelectorAll('#cryptoTableBody tr');
        
        // Get current fee rates once for all rows
        const feeRates = await getCurrentFeeRates();
        console.log(`Refreshing take-profits with fee rates - Maker: ${feeRates.maker}%, Taker: ${feeRates.taker}%`);
        
        for (const row of rows) {
            // Add validation for crypto title to prevent USD-only errors
            const titleEl = row.querySelector('.crypto-title');
            if (!titleEl || titleEl.textContent.trim() === 'USD') {
                // Skip rows with missing title or standalone USD
                continue;
            }
            
            // Get existing stop-loss value
            const stopLossInput = row.querySelector('.stop-loss-input');
            const takeProfitInput = row.querySelector('.take-profit-input');
            
            if (!stopLossInput || !takeProfitInput) continue;
            
            const displayStopLoss = parseFloat(stopLossInput.value);
            
            if (!isNaN(displayStopLoss)) {
                // Use our unified function to calculate both values
                const values = await calculateFeeAdjustedStopLossAndTakeProfit(displayStopLoss);
                
                // Set the take-profit input display value
                takeProfitInput.value = values.displayTakeProfit.toFixed(1);
                takeProfitInput.setAttribute('data-actual-value', values.actualTakeProfit.toFixed(1));
                takeProfitInput.setAttribute('data-fee-adjusted', 'true');
                
                const cryptoName = titleEl.textContent.trim().toUpperCase() + "USD";
                console.log(`${cryptoName}: Updated take-profit to maintain ratio with stop-loss ${displayStopLoss}%`);
            }
        }
    } catch (error) {
        console.error('Error refreshing take profits:', error);
    }
}

async function applyTakeProfit() {
    // Get the input value (display value)
    const displayValue = document.getElementById('takeProfitValue').value;
    if (!displayValue || isNaN(displayValue)) {
        alert('Please enter a valid number');
        return;
    }

    // Get fee rates
    const feeRates = await getCurrentFeeRates();
    
    // Convert DISPLAY value to ACTUAL value by ADDING fee
    // (Since display excludes fee impact)
    const actualValue = await calculateFeeAdjustedTakeProfit(parseFloat(displayValue));
    
    // Save both values
    localStorage.setItem('takeProfitValue', displayValue);
    localStorage.setItem('actualTakeProfitValue', actualValue.toFixed(1));

    console.log(`Applied take profit - Display: ${displayValue}%, Actual: ${actualValue.toFixed(1)}% (Fee: ${feeRates.taker}%)`);

    // Update all take-profit inputs with display value, storing actual as data attribute
    const takeProfitInputs = document.querySelectorAll('.take-profit-input');
    takeProfitInputs.forEach(input => {
        input.value = displayValue;
        input.setAttribute('data-actual-value', actualValue.toFixed(1));
    });
}

function handleStopLossChange(mode) {
    const controls = document.getElementById('fixedStopLossControls');
    const stopLossInputs = document.querySelectorAll('.stop-loss-input');
    const stopLossContainers = document.querySelectorAll('.trade-cell div:has(.stop-loss-input)');
    
    switch (mode) {
        case 'recommended':
            controls.style.display = 'none';
            stopLossContainers.forEach(container => {
                container.style.display = 'flex';
            });
            stopLossInputs.forEach(input => {
                input.style.display = '';
                input.previousElementSibling.style.visibility = 'visible'; // Show label
            });
            refreshAllLimits();
            break;
            
        case 'fixed':
            controls.style.display = 'inline-block';
            stopLossContainers.forEach(container => {
                container.style.display = 'flex';
            });
            stopLossInputs.forEach(input => {
                input.style.display = '';
                input.previousElementSibling.style.visibility = 'visible'; // Show label
            });
            break;
    }
}

async function applyFixedStopLoss() {
    // Get the input value (display value)
    const displayValue = document.getElementById('fixedStopLossValue').value;
    if (!displayValue || isNaN(displayValue)) {
        alert('Please enter a valid number');
        return;
    }
    
    // Calculate both stop-loss and take-profit with proper ratio
    const values = await calculateFeeAdjustedStopLossAndTakeProfit(parseFloat(displayValue));
    
    // Save values
    localStorage.setItem('fixedStopLossValue', displayValue);
    localStorage.setItem('actualFixedStopLossValue', values.actualStopLoss.toFixed(1));
    
    console.log(`Applied stop loss with ratio-preserving values - Display: ${displayValue}%`);
    
    // Update all stop-loss inputs
    const stopLossInputs = document.querySelectorAll('.stop-loss-input');
    stopLossInputs.forEach(input => {
        input.value = values.displayStopLoss.toFixed(1);
        input.setAttribute('data-actual-value', values.actualStopLoss.toFixed(1));
    });
    
    // If take profit is in fixed mode, update the take-profit values too
    if (document.getElementById('takeProfitSelect').value === 'fixed') {
        const takeProfitInputs = document.querySelectorAll('.take-profit-input');
        takeProfitInputs.forEach(input => {
            input.value = values.displayTakeProfit.toFixed(1);
            input.setAttribute('data-actual-value', values.actualTakeProfit.toFixed(1));
        });
        
        // Also update the take profit input field
        const takeProfitValue = document.getElementById('takeProfitValue');
        if (takeProfitValue) {
            takeProfitValue.value = values.displayTakeProfit.toFixed(1);
            localStorage.setItem('takeProfitValue', values.displayTakeProfit.toFixed(1));
            localStorage.setItem('actualTakeProfitValue', values.actualTakeProfit.toFixed(1));
        }
    }
}

function hideAllStopLossFields() {
    // Add logic to hide stop-loss related fields in the trade section
    const stopLossInputs = document.querySelectorAll('input[type="text"]');
    stopLossInputs.forEach(input => {
        if (input.id !== 'fixedStopLossValue') {
            input.closest('div').style.display = 'none';
        }
    });
}

function restoreRecommendedStopLoss() {
    // Show all stop-loss fields
    const stopLossInputs = document.querySelectorAll('input[type="text"]');
    stopLossInputs.forEach(input => {
        if (input.id !== 'fixedStopLossValue') {
            input.closest('div').style.display = '';
        }
    });
    
    // Refresh limits to restore recommended values
    refreshAllLimits();
}

function saveStopLossPreferences() {
    const preferences = {
        mode: document.getElementById('stopLossSelect').value,
        fixedValue: document.getElementById('fixedStopLossValue').value
    };
    localStorage.setItem('stopLossPreferences', JSON.stringify(preferences));
}

function loadStopLossPreferences() {
    const saved = localStorage.getItem('stopLossPreferences');
    if (saved) {
        const preferences = JSON.parse(saved);
        document.getElementById('stopLossSelect').value = preferences.mode;
        document.getElementById('fixedStopLossValue').value = preferences.fixedValue;
        handleStopLossChange(preferences.mode);
    }
}

// Start the timer update interval
setInterval(updateTimer, 1000);

/**
 * Apply fee adjustments to the trailing-stop-buy process
 * This function should be called before sending the trade request
 */
async function applyFeeAdjustments(orderData) {
    if (!orderData) return orderData;
    
    const stopLossPercent = parseFloat(orderData.sell_percent);
    const takeProfitPercent = parseFloat(orderData.take_profit);
    
    // Apply fee adjustments if values are valid numbers
    if (!isNaN(stopLossPercent) && stopLossPercent > 0) {
        orderData.sell_percent = await calculateFeeAdjustedStopLoss(stopLossPercent);
    }
    
    if (!isNaN(takeProfitPercent) && takeProfitPercent > 0) {
        orderData.take_profit = await calculateFeeAdjustedTakeProfit(takeProfitPercent);
    }
    
    return orderData;
}

async function updateTakeProfitAndPlaceOrder(button) {
  const container = button.closest('tr') || button.closest('.crypto-item');
  if (!container) return;

  try {
      const rowId = container.getAttribute('data-row-id');
      const statusResp = await fetch(`/order/status/${rowId}`);
      const state = await statusResp.json();

      // If trade is completed, reset state for a new trade
      if (state.status === "completed") {
      // Reset logic (unchanged)
          console.log(`DEBUG: Trade ${rowId} completed. Resetting for new trade.`);
          const newTradeResp = await fetch('/order/update_take_profit', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ row_id: rowId })
          });
      if (!newTradeResp.ok) throw new Error('Failed to open a new trade');
          alert("New trade opened successfully!");
          return;
      }

    // Show pending status (unchanged)
      const statusText = container.querySelector('.status-text');
      const buyOrderStatus = container.querySelector('.buyOrderStatus');
      
      if (statusText) statusText.style.display = 'none';
      if (buyOrderStatus) {
          buyOrderStatus.style.display = 'inline';
          buyOrderStatus.textContent = "Opening Buy Order...";
          buyOrderStatus.style.color = "yellow";
      }
      
      // Change button appearance
      button.textContent = "Cancel";
      button.style.backgroundColor = "#cd3331";
      button.classList.add("cancel-button");
      button.onclick = () => cancelOrder(button);
      button.onmouseover = () => button.style.backgroundColor = "#a62a28";
      button.onmouseout = () => button.style.backgroundColor = "#cd3331";
      
      // Get input values
      const takeProfitInput = container.querySelector('.take-profit-input');
      const stopLossInput = container.querySelector('.stop-loss-input');
      const usdAmountInput = container.querySelector('input[type="number"]');
      const pair = container.querySelector('.crypto-title').textContent.trim();
      
      // Get displayed input values (what the user sees)
      const takeProfitDisplayValue = takeProfitInput ? parseFloat(takeProfitInput.value) : null;
      const stopLossDisplayValue = stopLossInput ? parseFloat(stopLossInput.value) : 0;
      const usdAmount = usdAmountInput ? parseFloat(usdAmountInput.value) : 0;
      
      // Get actual values (which include fee adjustments) from data attributes
      const takeProfitActualValue = takeProfitInput ? 
          parseFloat(takeProfitInput.getAttribute('data-actual-value') || takeProfitInput.value) : 
          null;
      const stopLossActualValue = stopLossInput ? 
          parseFloat(stopLossInput.getAttribute('data-actual-value') || stopLossInput.value) : 
          0;

      console.log("Using fee-adjusted values for order:", {
          stopLossDisplay: stopLossDisplayValue,
      stopLossActual: stopLossActualValue,
          takeProfitDisplay: takeProfitDisplayValue,
      takeProfitActual: takeProfitActualValue
      });

      // Add this line to get the current stop-loss mode
      const stopLossMode = document.getElementById('stopLossSelect').value;

      console.log("DEBUG: Placing order with params:", {
          rowId, 
          pair, 
          usdAmount, 
      stopLossActualValue,
      stopLossDisplayValue,
      takeProfitActualValue,
      takeProfitDisplayValue,
      stopLossMode
    });

      // Validation
    if (!rowId || !takeProfitActualValue || !pair || usdAmount <= 0 || (stopLossMode !== "none" && stopLossActualValue <= 0)) {
          throw new Error('Missing or invalid parameters');
      }

    // Check minimum amount (unchanged)
    const rocData = await fetch(`/api/eval_roc?pair=${pair}USD`).then(r => r.json());
      if (rocData.min_usd && usdAmount < rocData.min_usd) {
          throw new Error(`This cryptocurrency requires a minimum order of $${rocData.min_usd}`);
      }        

      // Update take profit
      const takeProfitResp = await fetch('/order/update_take_profit', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ row_id: rowId, take_profit: takeProfitActualValue })
      });

      if (!takeProfitResp.ok) {
          throw new Error('Failed to update take profit');
      }

      // Place the buy order with request ID
      const requestId = generateRequestId();
      console.log("DEBUG: Generated request ID:", requestId);

      // Create order data using ACTUAL values, not display values
      let orderData = {
          row_id: rowId,
          pair: pair + "USD",
          usd_amount: usdAmount,
          sell_percent: stopLossActualValue, // Use actual value (minus fees)
          take_profit: takeProfitActualValue, // Use actual value (plus fees)
          stop_loss_mode: stopLossMode
      };

    console.log("DEBUG: Sending order with ACTUAL values:", orderData);

      const buyResp = await fetch('/order/trailing_stop_buy', {
          method: 'POST',
          headers: {
              'Content-Type': 'application/json',
              'X-Request-ID': requestId
          },
          body: JSON.stringify(orderData)
      });

      if (!buyResp.ok) {
          const error = await buyResp.json();
          throw new Error(error.error || 'Failed to place buy order');
      }

      const buyData = await buyResp.json();
      console.log("DEBUG: Order placed successfully:", buyData);

      // Update UI after placing the order
      button.textContent = "Cancel";
      button.style.backgroundColor = "#cd3331";
      button.classList.add("cancel-button");
      button.onclick = () => cancelOrder(button);
      button.onmouseover = () => button.style.backgroundColor = "#a62a28";
      button.onmouseout = () => button.style.backgroundColor = "#cd3331";

      // Update status to show initial buy order state
      if (buyOrderStatus) {
          const pctSpan = document.createElement('span');
          pctSpan.id = `pct-${rowId}`;
          buyOrderStatus.textContent = 'Buy Order Open [';
          buyOrderStatus.appendChild(pctSpan);
          buyOrderStatus.appendChild(document.createTextNode(']'));
          buyOrderStatus.style.color = "yellow";
          
          // Start tracking immediately
          trackBuyOrderPCT(rowId, buyData.details?.price);
      }

      // Start polling for order status
      startOrderStatusPolling(rowId, container);

  } catch (error) {
      console.error('Error in updateTakeProfitAndPlaceOrder:', error);
      
      // Reset status on error
      const buyOrderStatus = container.querySelector('.buyOrderStatus');
      const statusText = container.querySelector('.status-text');

      if (buyOrderStatus) {
          buyOrderStatus.textContent = "Order Failed";
          buyOrderStatus.style.color = "red";
          setTimeout(() => {
              buyOrderStatus.style.display = 'none';
              if (statusText) statusText.style.display = 'inline';
          }, 3000);
      }

      // Reset button on error
      button.disabled = false;
      button.textContent = "Trade";
      button.classList.remove("cancel-button");
      button.style.backgroundColor = "green";
      button.onclick = () => updateTakeProfitAndPlaceOrder(button);
      
      alert(error.message || 'Failed to update take profit and place order');
  }
}

// Enhanced place_stop_loss_sell function to account for fees
async function place_stop_loss_sell_with_fees(pair, volume, stop_loss_percent) {
    try {
        // Adjust stop-loss percentage for fees
        const adjustedStopLoss = await calculateFeeAdjustedStopLoss(stop_loss_percent);
        
        console.log(`Placing fee-adjusted stop-loss: Original ${stop_loss_percent}% â†’ Adjusted ${adjustedStopLoss.toFixed(2)}%`);
        
        // Call original function with adjusted value
        // This assumes place_stop_loss_sell exists in your code
        const txid = await place_stop_loss_sell(pair, volume, adjustedStopLoss, current_price);
        
        return txid;
    } catch (error) {
        console.error("Error in fee-adjusted stop-loss placement:", error);
        throw error;
    }
}

function trackBuyOrderPCT(rowId, limitPrice) {
    const el = document.getElementById("pct-" + rowId);
    if (!el) return;

    // Store interval ID in a global object to prevent multiple intervals
    if (!window.pctTrackers) window.pctTrackers = {};  

    // Clear existing interval if any
    if (window.pctTrackers[rowId]) {
        clearInterval(window.pctTrackers[rowId]);
    }

    // Initial update
    updatePCT();

    // Create new interval
    window.pctTrackers[rowId] = setInterval(updatePCT, 3000);

    // Function to update PCT
    async function updatePCT() {
        try {
            const response = await fetch(`/order/status/${rowId}`);
            const data = await response.json();
            
            if (data.status !== "buy_open") {
                clearInterval(window.pctTrackers[rowId]);
                delete window.pctTrackers[rowId];
                return;
            }
            
            if (data.current_price && data.buy_price) {
                // Determine order type
                const orderType = data.buy_order_type || 'limit'; // Default to limit for buy orders
                
                // Calculate percentage with fees
                const percentDiff = await calculatePercentageWithFees(
                    data.current_price, 
                    data.buy_price, 
                    orderType,
                    true
                );
                
                const sign = percentDiff >= 0 ? "+" : "";
                el.textContent = `${sign}${percentDiff.toFixed(2)}%`;
            } else if (data.buy_price_diff !== undefined) {
                // Fallback to pre-calculated value if we don't have prices
                const sign = data.buy_price_diff >= 0 ? "+" : "";
                el.textContent = `${sign}${data.buy_price_diff.toFixed(2)}%`;
            }
        } catch (err) {
            console.error("PCT tracking error:", err);
            clearInterval(window.pctTrackers[rowId]);
            delete window.pctTrackers[rowId];
        }
    }
}

function monitorOrder(rowId, buyPriceElemId, sellPercentElemId) {
  const intv = setInterval(() => {
    fetch("/order/status/" + rowId)
      .then(r => r.json())
      .then(data => {
        if (!data.status || data.status === "completed" || data.status === "cancelled") {
          clearInterval(intv);
          return;
        }
        if (data.priceDiff !== undefined) {
          document.getElementById(buyPriceElemId).textContent = data.priceDiff.toFixed(4);
        }
        if (data.status === "buy_filled") {
          // Immediately place stop-loss sell
          fetch("/order/stop_loss_sell", {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({
              row_id: rowId,
              sell_percent: document.getElementById(sellPercentElemId).value
            })
          });
        }
        if (data.status === "sell_open") {
          // Change text from Buy... to Sell...
          const pct = data.gainLossPct;
          document.getElementById(buyPriceElemId).textContent = `Sell Order Open [${pct.toFixed(2)}%]`;
          setButtonState(rowId, 'sell', 'enabled');
          setButtonState(rowId, 'buy', 'disabled');
        }
      })
      .catch(err => console.error("Monitoring error:", err));
  }, 3000);
}

function sellNow(rowId) {
  // Immediately place a limit sell at buyPrice + current gain
  fetch("/order/limit_sell_now", {
    method: "POST",
    headers: {"Content-Type": "application/json"},
    body: JSON.stringify({row_id: rowId})
  });
}

async function applyAmountSelection(value) {
    // Skip if initialization is already in progress
    if (window.initializationState.isInitializing) {
        console.log('Skipping amount selection - initialization in progress');
        return;
    }

    // Skip if minimum amounts haven't been set yet
    if (!window.initializationState.minimumAmountsSet) {
        console.log('Skipping amount selection - minimum amounts not yet initialized');
        return;
    }

    console.log('Starting amount selection application:', value);
    localStorage.setItem("amountSelection", value);

    // Get all amount inputs
    const amountInputs = document.querySelectorAll('input[type="number"]');
    console.log(`Processing ${amountInputs.length} amount inputs`);
    
    // Process each input
    for (const input of amountInputs) {
        const container = input.closest('tr') || input.closest('.crypto-item');
        const titleEl = container.querySelector('.crypto-title');
        if (!titleEl) continue;
        
        const cryptoName = titleEl.textContent.trim().toUpperCase() + "USD";
        const amountLabel = input.previousElementSibling;
        
        // Calculate the amount based on selection
        let selectedAmount;
        if (value.includes('%')) {
            // Handle percentage values
            try {
                const percentage = parseFloat(value) / 100;
                const resp = await fetch("/api/account_balance");
                const data = await resp.json();
                const balance = data.balance;
                selectedAmount = Math.floor(balance * percentage);
            } catch (error) {
                console.error("Error calculating percentage amount:", error);
                selectedAmount = 20; // Default fallback
            }
        } else {
            selectedAmount = parseFloat(value);
        }
        
        // Get minimum amount for this crypto
        let minAmount = 0;
        try {
            const resp = await fetch(`/api/eval_roc?pair=${cryptoName}`);
            if (resp.ok) {
                const data = await resp.json();
                minAmount = data.min_usd || 0;
            }
        } catch (error) {
            console.error(`Error checking minimum for ${cryptoName}:`, error);
        }
        
        // Apply the amount, respecting minimums
        if (minAmount > 0 && minAmount > selectedAmount) {
                input.value = minAmount;
                amountLabel.innerHTML = '<span style="color: red; font-weight: bold; background: black; padding: 2px 4px;">MINIMUM</span>';
        } else {
            input.value = selectedAmount;
            amountLabel.textContent = 'Amount';
        }
    }

    window.initializationState.savedAmountApplied = true;
    console.log('Amount selection application complete');
    
    // After setting all amounts, refresh recommendations with fee adjustments
    setTimeout(refreshRecommendedValues, 200);
}

window.addEventListener("DOMContentLoaded", () => {
  const saved = localStorage.getItem("amountSelection");
  if(saved) {
    document.getElementById("amountDropdown").value = saved;
    applyAmountSelection(saved);
  }
});

const GraphToggleButton = () => {
        const [isRevealed, setIsRevealed] = React.useState(false);
      
        const toggleAllGraphs = () => {
          const expanders = document.querySelectorAll('.chart-expander');
          const chartRows = document.querySelectorAll('.chart-row');
          
          setIsRevealed(!isRevealed);
          
          expanders.forEach(expander => {
            // Only toggle if current state doesn't match desired state
            const isCurrentlyExpanded = expander.style.transform === 'rotate(90deg)';
            if (isCurrentlyExpanded !== !isRevealed) {
              expander.click();
            }
          });
      
          // Ensure visibility of chart rows matches the state
          chartRows.forEach(row => {
            if (!isRevealed) {
              row.classList.add('chart-row-visible');
            } else {
              row.classList.remove('chart-row-visible');
            }
          });
        };
      
        return React.createElement('button', {
          className: 'trading-button',
          style: {
            padding: '8px 20px',
            borderRadius: '5px',
            backgroundColor: '#447a7b',
            height: '32px',
            lineHeight: '1',
            color: 'white',
            border: 'none',
            cursor: 'pointer'
          },
          onMouseOver: (e) => e.target.style.backgroundColor = '#325c5d',
          onMouseOut: (e) => e.target.style.backgroundColor = '#447a7b',
          onClick: toggleAllGraphs
        }, isRevealed ? 'Hide Graphs' : 'Reveal Graphs');
      };

      document.addEventListener('DOMContentLoaded', function() {
            const graphToggleRoot = document.getElementById('graph-toggle-root');
            if (graphToggleRoot) {
                ReactDOM.createRoot(graphToggleRoot).render(React.createElement(GraphToggleButton));
            }
        });
</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="/components/OptimalTime.js"></script>
    <script type="importmap">
        {
          "imports": {
            "react-dom/client": "https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js",
            "react": "https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"
          }
        }
        </script>
</head>
<body>
<!-- Account Info Popup -->
<div class="popup-overlay" id="accountOverlay"></div>
<div class="account-popup" id="accountPopup">
    <button class="close-btn" onclick="closeAccountPopup()">&times;</button>
    <h1 class="account-info-title">Account Information</h1>
    <hr style="border: 1px solid #454545;"><br>
        <div class="account-section">
            <h2 class="account-section-title">Balances</h2>
            <table class="account-table">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Quantity</th>
                        <th>Amount (USD)</th>
                    </tr>
                </thead>
                <tbody id="balancesTable"></tbody>
            </table>
        </div><br>
            <div class="account-section">
                <h2 class="account-section-title">Orders</h2>
                <table class="account-table">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Order</th>
                        <th>Status</th>
                        <th>Quantity</th>
                        <th>Amount (USD)</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody id="ordersTable"></tbody>
            </table>
        </div>
    </div>
</div>
<div style="width: 95%; margin: 0 auto; display: flex; justify-content: space-between; align-items: center; padding: 10px 0; margin-bottom: -10px; gap: 5px;">
    <div style="display: flex; align-items: center; background-color: #000; padding: 8px 15px; margin: 0; border-radius: 4px; gap: 10px; width: 260px; height: 30px;">
        <img src="https://displaying.xyz/favicon.ico" alt="Cryptomatic Icon" style="width: 18px; height: 18px;">
        <h1 style="font-size: 20px; letter-spacing: 4px; margin: 0;">CRYPTOMATIC</h1>
    </div>

    <div id="crypto-news-bar" style="flex-grow: 1; background-color: black; padding: 8px 15px; margin: 0 10px; border-radius: 4px; height: 30px; display: flex; align-items: center; justify-content: center;">
        <span id="crypto-news-content" style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: #d8a239;">Loading crypto news...</span>
    </div>

    <div style="display: flex; justify-content: space-between; align-items: center; background-color: #000; padding: 8px 15px; margin: 0; border-radius: 4px; font-size: 14px; width: 260px; height: 30px;">
        <select id="autoRefreshSelect" style="background-color: #000; color: white; border: none; font-size: 14px; cursor: pointer; max-width: 160px;" onchange="updateAutoRefresh(this.value)">
            <option value="0">Auto Refresh: Off</option>
            <option value="1">Auto Refresh: 1 mn</option>
            <option value="2">Auto Refresh: 2 mn</option>
            <option value="5">Auto Refresh: 5 mn</option>
            <option value="10">Auto Refresh: 10 mn</option>
            <option value="15">Auto Refresh: 15 mn</option>
            <option value="30">Auto Refresh: 30 mn</option>
            <option value="45">Auto Refresh: 45 mn</option>
            <option value="60">Auto Refresh: 1 h</option>
        </select>
        <p id="timer" style="margin: 0; min-width: 70px; text-align: right; white-space: nowrap;"></p>
    </div>
</div>

<!-- Center buttons container -->
<div style="width: max-content; margin: 10px auto; display: flex; gap: 5px; align-items: center;">
    <button 
        class="trading-button"
        style="padding: 8px 20px; border-radius: 5px; background-color: #888888; height: 32px; line-height: 1;"
        onmouseover="this.style.backgroundColor='#666666';"
        onmouseout="this.style.backgroundColor='#888888';"
        onclick="showAccountInfo()"
    >
        Check Account
    </button>
    <div id="graph-toggle-root"></div>
    <button 
        class="trading-button"
        style="padding: 8px 20px; border-radius: 5px; height: 32px; line-height: 1;"
        onclick="refreshAllLimits()"
    >
        Refresh All
    </button>
    <button 
        class="trading-button"
        style="padding: 8px 20px; border-radius: 5px; height: 32px; line-height: 1; background-color: #ff8c00;"
        onmouseover="this.style.backgroundColor='#e67e00';"
        onmouseout="this.style.backgroundColor='#ff8c00';"
        onclick="toggleAutoTrade()"
    >
        Auto-Trade
    </button>
</div>

</div>

<script>
let lastAccountCheck = 0;
const ACCOUNT_CHECK_COOLDOWN = 5000; // 5 seconds

async function showAccountInfo() {
    const now = Date.now();
    if (now - lastAccountCheck < ACCOUNT_CHECK_COOLDOWN) {
        alert('Please wait a few seconds between account checks');
        return;
    }

    lastAccountCheck = now;
    try {
        const overlay = document.getElementById('accountOverlay');
        const popup = document.getElementById('accountPopup');
        const balancesTable = document.getElementById('balancesTable');
        const ordersTable = document.getElementById('ordersTable');
        
        // Show loading state
        balancesTable.innerHTML = '<tr><td colspan="3">Loading...</td></tr>';
        ordersTable.innerHTML = '<tr><td colspan="6">Loading...</td></tr>';
        
        overlay.style.display = 'block';
        popup.style.display = 'block';
        
        // Add delay between requests
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // Fetch account data
        const response = await fetch('/api/check_account');
        
        if (!response.ok) {
            const errorData = await response.json();
            if (errorData.error?.includes('Rate limit exceeded')) {
                throw new Error('Rate limit reached. Please wait a few seconds and try again.');
            }
            throw new Error(errorData.error || 'Failed to fetch account data');
        }
        
        const data = await response.json();
        
        if (data.error) {
            throw new Error(data.error);
        }
        
        // Update balances table
        balancesTable.innerHTML = data.balances
            .map(balance => `
                <tr>
                    <td>${balance.name}</td>
                    <td>${balance.quantity.toFixed(8)}</td>
                    <td>$${balance.usd_amount.toFixed(2)}</td>
                </tr>
            `)
            .join('');
            
        // Update orders table
        ordersTable.innerHTML = data.orders
            .map(order => `
                <tr>
                    <td>${order.name}</td>
                    <td>${order.order}</td>
                    <td>${order.status}</td>
                    <td>${order.quantity.toFixed(8)}</td>
                    <td>$${order.usd_amount.toFixed(2)}</td>
                    <td>
                        <button 
                            class="cancel-order-btn" 
                            onclick="cancelKrakenOrder('${order.id}')"
                        >
                            Cancel
                        </button>
                    </td>
                </tr>
            `)
            .join('');
            
        if (data.orders.length === 0) {
            ordersTable.innerHTML = '<tr><td colspan="6">No open orders</td></tr>';
        }
        
    } catch (error) {
        console.error('Error fetching account info:', error);
        alert(`Failed to fetch account information: ${error.message}`);
        
        // Close popup on error
        document.getElementById('accountOverlay').style.display = 'none';
        document.getElementById('accountPopup').style.display = 'none';
    }
}

function closeAccountPopup() {
    document.getElementById('accountOverlay').style.display = 'none';
    document.getElementById('accountPopup').style.display = 'none';
}

async function cancelKrakenOrder(orderId) {
    try {
        const response = await fetch(`/api/cancel_order/${orderId}`, {
            method: 'POST'
        });
        
        const data = await response.json();
        if (data.error) {
            throw new Error(data.error);
        }
        
        // Find corresponding row in main table
        const tableRows = document.querySelectorAll('#cryptoTableBody tr');
        for (const row of tableRows) {
            const buyOrderStatus = row.querySelector('.buyOrderStatus');
            const defaultText = row.querySelector('.status-text');
            const tradeButton = row.querySelector('button:not(.sell-btn):not(.buy-btn)');

            // Reset UI elements
            if (buyOrderStatus) buyOrderStatus.style.display = 'none';
            if (defaultText) {
                defaultText.style.display = 'inline';
                defaultText.textContent = 'Inactive';
            }
            if (tradeButton) {
                tradeButton.textContent = 'Trade';
                tradeButton.classList.remove('cancel-button');  // Remove cancel button class
                tradeButton.style.backgroundColor = 'green';
                tradeButton.onmouseover = () => tradeButton.style.backgroundColor = 'darkgreen';
                tradeButton.onmouseout = () => tradeButton.style.backgroundColor = 'green';
                tradeButton.onclick = () => placeTrailingStopBuy(tradeButton);
            }
        }
        
        // Clear any saved state for this row
        const rowId = `row-${orderId}`;
        if (orderPollingIntervals[rowId]) {
            clearInterval(orderPollingIntervals[rowId]);
            delete orderPollingIntervals[rowId];
        }
        if (window.pctTrackers && window.pctTrackers[rowId]) {
            clearInterval(window.pctTrackers[rowId]);
            delete window.pctTrackers[rowId];
        }
        
        // Refresh the account info to show updated orders
        await showAccountInfo();
        
    } catch (error) {
        console.error('Error canceling order:', error);
        alert('Failed to cancel order: ' + error.message);
    }
}

async function testConnection() {
    const response = await fetch('/api/test_connection');
    const data = await response.json();
    alert(JSON.stringify(data, null, 2));
}
</script>
    </span>
</div>
<!-- Stop-Loss Options -->
<div style="text-align: center; margin-top: 10px;">
    <div class="flex items-center justify-center gap-2">
        <select id="stopLossSelect" 
                style="background-color: #1e1e1e; 
                       color: white; 
                       border: 1px solid #444; 
                       border-radius: 5px; 
                       padding: 8px 12px; 
                       cursor: pointer;">
            <option value="recommended">Recommended Stop-loss</option>
            <option value="fixed">Stop-loss at</option>
        </select>
        
        <div id="fixedStopLossControls" style="display: none;">
            <input type="text" 
                   id="fixedStopLossValue" 
                   style="background-color: #1e1e1e;
                          color: white;
                          border: 1px solid #444;
                          border-radius: 5px;
                          padding: 5px;
                          width: 5ch;">
            <span>%</span>
            <button id="applyStopLoss" 
                    style="background-color: rgb(7, 131, 184);
                           color: white;
                           border: none;
                           border-radius: 5px;
                           padding: 8px 15px;
                           cursor: pointer;
                           margin-left: 5px;"
                    onmouseover="this.style.backgroundColor='rgb(15, 88, 134)';"
                    onmouseout="this.style.backgroundColor='rgb(7, 131, 184)';">
                Apply
            </button>
        </div>

        <!-- Take Profit Select -->
        <select id="takeProfitSelect" 
                style="background-color: #1e1e1e; 
                    color: white; 
                    border: 1px solid #444; 
                    border-radius: 5px; 
                    padding: 8px 12px; 
                    cursor: pointer;">
            <option value="recommended">Recommended Take Profit</option>
            <option value="fixed">Take Profit at</option>
        </select>

        <!-- Take Profit Value Controls -->
        <div id="takeProfitControls" style="display: none;">
            <input type="text" 
                   id="takeProfitValue"
                   style="background-color: #1e1e1e;
                          color: white;
                          border: 1px solid #444;
                          border-radius: 5px;
                          padding: 5px;
                          width: 5ch;">
            <span>%</span>
            <button id="applyTakeProfit" 
            style="background-color: rgb(7, 131, 184);
                   color: white;
                   border: none;
                   border-radius: 5px;
                   padding: 8px 15px;
                   cursor: pointer;
                   margin-left: 5px;"
            onmouseover="this.style.backgroundColor='rgb(15, 88, 134)';"
            onmouseout="this.style.backgroundColor='rgb(7, 131, 184)';">
        Apply
    </button>
        </div>

        <!-- Amount Dropdown -->
        <select id="amountDropdown" onchange="applyAmountSelection(this.value)" 
            style="background-color: #1e1e1e; 
                   color: white; 
                   border: 1px solid #444; 
                   border-radius: 5px; 
                   padding: 8px 12px; 
                   cursor: pointer;">
            <option value="10">Amount: $10</option>
            <option value="20">Amount: $20</option>
            <option value="100">Amount: $100</option>
            <option value="10%">Amount: 10%</option>
            <option value="50%">Amount: 50%</option>
            <option value="95%">Amount: 95%</option>
            <option value="100%">Amount: 100%</option>
        </select>
        <!-- Sell Type Dropdown -->
        <select id="sellTypeDropdown" 
                class="sell-type-select"
                style="background-color: #1e1e1e; 
                    color: white; 
                    border: 1px solid #444; 
                    border-radius: 5px; 
                    padding: 8px 12px; 
                    cursor: pointer;">
            <option value="market">Market Sell (Immediate)</option>
            <option value="limit">Limit Sell (Target %)</option>
        </select>
    </div>
</div>

<div id="orderMonitorRoot"></div>
<!-- Main table -->
<table id="cryptoTable">
    <thead>
        <tr>
            <th onclick="sortTable(0)">
                Name
                <span class="arrow-up">&#9650;</span>
                <span class="arrow-down">&#9660;</span>
            </th>
            <th onclick="sortTable(1)">
                Price
                <span class="arrow-up">&#9650;</span>
                <span class="arrow-down">&#9660;</span>
            </th>
            <th onclick="sortTable(2)">
                RoC
                <span class="arrow-up">&#9650;</span>
                <span class="arrow-down">&#9660;</span>
            </th>
            <th onclick="sortTable(3)">
                Spread
                <span class="arrow-up">&#9650;</span>
                <span class="arrow-down">&#9660;</span>
            </th>
            <th onclick="sortTable(4)">
                Volume
                <span class="arrow-up">&#9650;</span>
                <span class="arrow-down">&#9660;</span>
            </th>
            <th onclick="sortTable(5)">
                Gain
                <span class="arrow-up">&#9650;</span>
                <span class="arrow-down">&#9660;</span>
            </th>
            <th onclick="sortTable(6)">
                High | Low
                <span class="arrow-up">&#9650;</span>
                <span class="arrow-down">&#9660;</span>
            </th>
            <th onclick="sortTable(7)">
                Peak Time
                <span class="arrow-up">&#9650;</span>
                <span class="arrow-down">&#9660;</span>
            </th>
            <th>Trade</th>
        </tr>
    </thead>
    <tbody id="cryptoTableBody">
        {% for crypto in cryptos_script2 %}
        <tr data-row-id="row-{{ loop.index0 }}" 
        {% if crypto.pair.replace('USD', '') in tier1_cryptos %}
            style="background-color: #066c41;"
        {% elif crypto.pair.replace('USD', '') in tier2_cryptos %}
            style="background-color: #725f00;"
        {% endif %}>
        <td style="height: 50px;">
            <div style="display: flex; align-items: center; height: 100%;">
                <div style="width: 30px; display: flex; align-items: center; justify-content: center;">
                    <span 
                        class="chart-expander" 
                        style="cursor: pointer; transition: transform 0.3s ease;"
                        onclick="toggleCryptoChart(this)">
                        â–¶
                    </span>
                </div>
                <div style="flex-grow: 1; display: flex; flex-direction: column; justify-content: center; align-items: center;">
                    <div id="crypto-name-{{loop.index0}}"></div>
                    <script>
                        document.addEventListener('DOMContentLoaded', function() {
                            var el = document.getElementById('crypto-name-{{ loop.index0 }}');
                            if (el) {
                                ReactDOM.createRoot(el).render(React.createElement(CryptoName, {
                                    name: "{{ crypto.pair }}",
                                    conditions: JSON.parse('{{ crypto.conditions|tojson|safe }}')
                                }));
                            }
                        });
                    </script>
                </div>
            </div>
         </td>
            <td>${{ "%.4f" % crypto.price }}</td>
            <td>{{ "%.3f" % crypto.avg_roc }}% 
                {% if crypto.current_trend == "up" %}
                <span class="trend-up">&#9650;</span>
                {% elif crypto.current_trend == "down" %}
                <span class="trend-down">&#9660;</span>
                {% else %}
                <span class="neutral">-</span>
                {% endif %}
            </td>
            <td>{{ "%.2f" % crypto.roc_activity }}</td>
            <td>${{ "%.1f" % (crypto.volume / 1_000_000) }}M</td>
            <td>{{ crypto.one_percent_gain }}</td>
            <td>{{ crypto.high_low }}</td>
            <td id="optimal-time-{{ crypto.pair }}"></td>
            <td class="trade-cell" style="height: 50px; padding: 10px 0;">
                <div style="display: flex; align-items: flex-end; gap: 10px; height: 100%;">
                    <div style="display: flex; flex-direction: column; gap: 2px;">
                        <label style="font-size: 0.8em;">Loss %</label>
                        <input type="text" class="stop-loss-input" style="width: 4ch; padding: 4px 6px;">
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 2px;">
                        <label style="font-size: 0.8em;">Profit %</label>
                        <input type="text" class="take-profit-input" style="width: 4ch; padding: 4px 6px;">
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 2px;">
                        <label style="font-size: 0.8em;">Amount</label>
                        <input type="number" value="20" style="width: 10ch; padding: 4px 6px;">
                    </div>
                    <button
                        style="
                            background-color: green;
                            color: white;
                            border: none;
                            border-radius: 0;
                            height: 30px;
                            padding: 5px 15px;
                            cursor: pointer;
                            text-transform: uppercase;
                            align-self: flex-end;
                        "
                        onmouseover="this.style.backgroundColor='darkgreen';"
                        onmouseout="this.style.backgroundColor='green';"
                        onclick="updateTakeProfitAndPlaceOrder(this)"
                    >
                        Trade
                    </button>
                    <button
                        class="buy-btn"
                        onmouseover="this.style.backgroundColor='#005599';"
                        onmouseout="this.style.backgroundColor='#0077cc';"
                        onclick="marketBuy(this)"
                    >
                        Buy
                    </button>
                    <button
                        class="sell-btn"
                        onclick="marketSell(this)"
                    >
                        Sell
                    </button>

                    <div class="status-container" style="align-self: flex-end; height: 30px; display: flex; align-items: center;">
                        <div class="polling-dot"></div>
                        <span class="buyOrderStatus" style="display: none;"></span>
                        <span class="status-text">Inactive</span>
                    </div>
                </div>
            </td>                           
        </tr>
        {% endfor %}
    </tbody>
</table>

<!-- Results bar and transaction history -->
<div class="results-bar" onclick="toggleResults()">
    RESULTS <span class="down-arrow">â–¼</span>
</div>
<div class="results-content">
    <table class="transaction-table">
        <thead>
            <tr>
                <th>Date</th>
                <th>Total</th>
                <th>Trades</th>
            </tr>
        </thead>
        <tbody id="transactionTableBody">
        </tbody>
    </table>
</div>

<!-- Add this right after your React and ReactDOM script imports -->
<script>
    // Define createRoot helper function
    function createRoot(container) {
        return ReactDOM.createRoot(container);
    }
    
    // Define components inline instead of importing
    const OrderMonitor = () => {
        return React.createElement('div', null, 'Order Monitor');
    };
    
    const PricePrecisionHandler = ({ pair, onPrecisionUpdate }) => {
        return React.createElement('div', null);  // Empty div since this is just for handling precision
    };
    
    const PriceTracker = ({ rowId, orderType }) => {
        const [price, setPrice] = React.useState(null);
        
        React.useEffect(() => {
            // Price tracking logic here
        }, [rowId, orderType]);
        
        return null;  // This component doesn't render anything visible
    };

    document.getElementById('sellTypeDropdown').addEventListener('change', function() {
        localStorage.setItem('sellType', this.value);
    });

    // Initialize components after DOM loads
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize the Order Monitor
        const orderMonitorContainer = document.getElementById('orderMonitorRoot');
        if (orderMonitorContainer) {
            ReactDOM.createRoot(orderMonitorContainer).render(
                React.createElement(OrderMonitor)
            );
        }
    
        // Add price precision handling to each trade row
        document.querySelectorAll('#cryptoTableBody tr').forEach(row => {
            const pairElement = row.querySelector('.crypto-title');
            const pair = pairElement ? pairElement.textContent.trim() : null;
            
            if (pair) {
                const precisionContainer = document.createElement('div');
                precisionContainer.id = `precision-handler-${pair}`;
                row.appendChild(precisionContainer);
                
                ReactDOM.createRoot(precisionContainer).render(
                    React.createElement(PricePrecisionHandler, {
                        pair: pair,
                        onPrecisionUpdate: (newPrecision) => {
                            console.log(`Updated precision for ${pair} to ${newPrecision}`);
                        }
                    })
                );
            }
        });
    
        // Initialize price trackers
        document.querySelectorAll('[data-row-id]').forEach(row => {
            const rowId = row.getAttribute('data-row-id');
            const statusContainer = row.querySelector('.status-container');
            
            if (statusContainer) {
                const root = document.createElement('div');
                root.id = `price-tracker-${rowId}`;
                statusContainer.appendChild(root);
                
                ReactDOM.createRoot(root).render(
                    React.createElement(PriceTracker, {
                        rowId: rowId,
                        orderType: statusContainer.querySelector('.buyOrderStatus')?.textContent.toLowerCase().includes('buy') ? 'buy' : 'sell'
                    })
                );
            }
        });
    });
    </script>
    <div style="text-align: center; margin: 20px 0;">
        <button 
            onclick="testConnection()" 
            style="
            padding: 8px 15px; 
            background-color: transparent; 
            color: rgb(151, 147, 125); 
            border: 1px solid rgb(151, 147, 125); 
            font-size: 0.6em; 
            text-transform: uppercase; 
            cursor: pointer;
            "
            onmouseover="this.style.backgroundColor='#515151';"
            onmouseout="this.style.backgroundColor='transparent';"
        >
            Test API Connection
        </button>
        <button 
        onclick="checkForUpdates(event)" 
        style="
        padding: 8px 15px; 
        background-color: transparent; 
        color: rgb(151, 147, 125); 
        border: 1px solid rgb(151, 147, 125); 
        font-size: 0.6em; 
        text-transform: uppercase; 
        cursor: pointer;
        "
        onmouseover="this.style.backgroundColor='#515151';"
        onmouseout="this.style.backgroundColor='transparent';"
    >
        Update
    </button>
    </div>
</body>
</html>